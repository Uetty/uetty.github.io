<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>Vince Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Vince Blog">
<meta property="og:url" content="https://page.uetty.com/index.html">
<meta property="og:site_name" content="Vince Blog">
<meta property="og:locale" content="zh_CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Vince Blog">
  
    <link rel="alternate" href="/atom.xml" title="Vince Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Vince Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//www.baidu.com/s" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q1" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="q6" value="page.uetty.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-character-set-encoding" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/23/character-set-encoding/" class="article-date">
  <time datetime="2020-02-23T06:22:00.000Z" itemprop="datePublished">2020-02-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/23/character-set-encoding/">从二分图开始到最大匹配</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="图论概念"><a href="#图论概念" class="headerlink" title="图论概念"></a>图论概念</h2><ul>
<li>图：由顶点和顶点之间的边组成的集合，表示为G&lt;V, E&gt;，V表示的是顶点的集合，E表示的是边的集合</li>
<li>独立集：图内点集的子集，且满足：每两个顶点之间均不存在连边</li>
<li>最大独立集：图内顶点数量最多的独立集</li>
<li>覆盖：图内点集的子集，且满足：能覆盖（顶点是边的任一个端点都视为覆盖边）图的所有边</li>
<li>最小覆盖：图内顶点数量最少的覆盖</li>
<li>最小覆盖数：最小覆盖的顶点数量</li>
<li>匹配：图内边集的子集，且满足：任意两条边都没有公共顶点</li>
<li>最大匹配：图内边数量最多的匹配</li>
<li>最大匹配数：最大匹配的边数量</li>
</ul>
<h2 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h2><p>设G&lt;V, E&gt;是一个无向图，如果顶点V可分割为两个互不相交的子集(A, B)，并且图中每条边(i, j)的两个顶点分别属于两个不同的集合(i属于A, j属于B)，则程图G是二分图。</p>
<p>定理和推论：</p>
<ol>
<li>无向图G是二分图的充要条件是：G至少有两个顶点，且所有环的长度都为偶数</li>
<li>最大独立集顶点数量 = 图中顶点数量 - 最小点覆盖数</li>
<li>最小覆盖数 = 最大匹配数</li>
</ol>
<p>二分图充要条件证明见<a href="https://baike.baidu.com/item/%E4%BA%8C%E5%88%86%E5%9B%BE/9089095?fr=aladdin#3" target="_blank" rel="noopener">百度百科</a>（以<code>边跨集合A和B，形成环必然需要一次往返的倍数</code>这个思路考虑）</p>
<p>最大独立集顶点数量证明略（简单思考：去掉最小覆盖点，图中边自然也就不存在了）</p>
<h3 id="证明最小覆盖数等于最大匹配数"><a href="#证明最小覆盖数等于最大匹配数" class="headerlink" title="证明最小覆盖数等于最大匹配数"></a>证明最小覆盖数等于最大匹配数</h3><p>条件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">图G&lt;V,E&gt;</span><br><span class="line">存在点集C是最小点覆盖，最小覆盖数为c</span><br><span class="line">存在边集M是最大匹配，最大匹配数为m</span><br></pre></td></tr></table></figure>

<p>求证：m = c</p>
<p>证明：</p>
<blockquote>
<ol>
<li><p>点集C是覆盖，则边集M上的任意一条边，至少有一端点属于C，所以m &lt;= c  （光覆盖这些边就需要m个点）</p>
</li>
<li><p>点集C是最小覆盖，则有如下两点结论：</p>
<p>​    Ⅰ. 点集中每个点都<strong>至少能找到一个</strong>点集外的点与该点连边。如果没有，说明该点所有边端点都在覆盖中，那这个点也没必要包含了，与最小覆盖矛盾<br>​    Ⅱ. 点集中多个点<strong>都只能</strong>选择同一个点集外的点连边的情况也<strong>不会出现</strong>。如果出现，说明部分点不是必要的，就不是最小覆盖了。</p>
<p>上面两条保证了每个点都可以有一个覆盖外的点连边且这些连边不包含共同顶点，所以这些连边组成的边集是图G的一个匹配，所以m &gt;= c</p>
</li>
</ol>
<p>综上两点，m = c 得证</p>
</blockquote>
<h2 id="寻找最大匹配（匈牙利算法）"><a href="#寻找最大匹配（匈牙利算法）" class="headerlink" title="寻找最大匹配（匈牙利算法）"></a>寻找最大匹配（匈牙利算法）</h2><p>交错路径：给定图G的一个匹配M，如果一条路径的边，交替出现在M中和不出现在M中，则称为M-交错路径</p>
<p>增广路径：如果一条M-交错路径，两个端点都不与M中的边关联，则称为M-增广路径</p>
<p>可以使用匈牙利算法查找二分图中的最大匹配，如图所示，点集G&lt;V, E&gt;是一个二分图，可分独立集A和独立集B </p>
<p><img src="../static/MB20022301-1.png" alt="图1"></p>
<p>具体算法如下：</p>
<ol>
<li><p>每次从集合A中取一个未被选取的点，查看该点覆盖的所有边，如果存在一条边的另一端点（位于集合B）也未被选取，则将这两点相连。不断重复该过程，如同所示，第一次选择A1和B1连线，点二次选择A2和B3连线</p>
<p><img src="../static/MB20022301-2.png" alt="图2">    <img src="../static/MB20022301-3.png" alt="图3"></p>
</li>
<li><p>如果A集合中选取的点，覆盖的所有边的另一端点均已被A集合上的点占去（如上图所示，A3覆盖的边A3B1的另一端点B1已经被A1占去），则尝试给占去Bj（该例中为B1）的点Ai（该例中为A1）换一个未被占用的点，如果又被占用，则继续考虑帮占用点换一个点…（这是一个递归过程）。实际上，这就是一个找增广路径的过程，因为要能找到这样的更换路径，在每次给占用点更换连线时，首先要求占用点有其他未连线的边，这样就形成了一个交替——边未匹配过、匹配过、未匹配过、匹配过、未匹配过…（奇数次且两端均是未匹配过）。</p>
<p>如下图所示，从A3出发，找到了一条路径：A3-&gt;B1-&gt;A1-&gt;B3-&gt;A2-&gt;B4（已匹配过的边颜色是红色）</p>
<p><img src="../static/MB20022301-4.png" alt="图4"></p>
<p>找到增广路径之后，将该条线上的红蓝色颜色对调（匹配与未匹配属性反转），就能找到一种总匹配数+1的匹配方式，如下图所示</p>
<p><img src="../static/MB20022301-5.png" alt="图5"></p>
</li>
</ol>
<p>重复1、2步，最终就能找到二分图G的最大匹配</p>
<p><img src="../static/MB20022301-6.png" alt="图6"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://page.uetty.com/2020/02/23/character-set-encoding/" data-id="ck71vzldl0000swukl56pkpk3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/图论/">图论</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-character-set-encoding" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/13/character-set-encoding/" class="article-date">
  <time datetime="2020-02-13T14:15:32.000Z" itemprop="datePublished">2020-02-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/13/character-set-encoding/">理解字符集编码及Java内存编码运行机制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="常见编码详悉"><a href="#常见编码详悉" class="headerlink" title="常见编码详悉"></a>常见编码详悉</h2><h3 id="Unicode和UTF-8的关系"><a href="#Unicode和UTF-8的关系" class="headerlink" title="Unicode和UTF-8的关系"></a>Unicode和UTF-8的关系</h3><p>Unicode又称万国码，它将全世界大部分语言的常用字符都纳入了编码范围。Unicode和UTF-8的关系简单的来说可以理解为：</p>
<ul>
<li>Unicode是字符集</li>
<li>UTF-8是编码规则</li>
</ul>
<p>字符集：为每一个“字符”分配一个唯一的数值（ID，或称码点、码位），即给汉字、英文等各种字符分配一个不重复的数值</p>
<p>编码规则：将“码点”转换为字节序列的规则（数值转化为字节值的过程）</p>
<p>Unicode字符集为每一个字符分配一个码点，例如：“中”的码点是20013，记作U+4E2D（20013的16进制是4E2D）</p>
<p>UTF-8是一套以8位为一个编码单位的可变长编码，会将一个码点编码为1到4个字节（广义上的UTF-8），编码规则如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> U+0000 ~   U+007F: 0XXXXXXX</span><br><span class="line"> U+0080 ~   U+07FF: 110XXXXX 10XXXXXX</span><br><span class="line"> U+0800 ~   U+FFFF: 1110XXXX 10XXXXXX 10XXXXXX</span><br><span class="line">U+10000 ~ U+10FFFF: 11110XXX 10XXXXXX 10XXXXXX 10XXXXXX</span><br></pre></td></tr></table></figure>

<p>根据上表可知，“中”字的码点U+4E2D属于第三行范围：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">       4    E    2    D</span><br><span class="line">‭    0100 1110 0010 1101‬    二进制值</span><br><span class="line">------------------------</span><br><span class="line">    0100   111000   101101 二进制值重新对齐</span><br><span class="line">1110XXXX 10XXXXXX 10XXXXXX 模板</span><br><span class="line">11100100 10111000 10101101 代入模板后值</span><br><span class="line">     228      184      173 字节值(byte，负值处理为正值了+256)</span><br></pre></td></tr></table></figure>

<p>我们可以用java编写程序实现unicode值（16进制表示）和字符的转换，如下所示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">public class UnicodeCoder &#123;</span><br><span class="line">	/**</span><br><span class="line">	 * 字符串转为unicode值，参数二是否将ASCII字符转为unicode表示</span><br><span class="line">	 */</span><br><span class="line">	public static String encode(String str, boolean encodeAscii) &#123;</span><br><span class="line">		StringBuilder sb = new StringBuilder();</span><br><span class="line">		char[] charArray = str.toCharArray();</span><br><span class="line">		for (int i = 0; i &lt; charArray.length; i++) &#123;</span><br><span class="line">			char c = charArray[i];</span><br><span class="line">			sb.append(charToUnicodeString(c, encodeAscii));</span><br><span class="line">		&#125;</span><br><span class="line">		return sb.toString();</span><br><span class="line">	&#125;</span><br><span class="line">	/**</span><br><span class="line">	 * unicode值转为字符串</span><br><span class="line">	 */</span><br><span class="line">	public static String decode(String str) throws UnsupportDecodeException &#123;</span><br><span class="line">		StringBuilder sb = new StringBuilder();</span><br><span class="line">		char[] charArray = str.toCharArray();</span><br><span class="line">		for (int i = 0; i &lt; charArray.length; i++) &#123;</span><br><span class="line">			char c = charArray[i];</span><br><span class="line">			if (c == &apos;\\&apos;) &#123;</span><br><span class="line">				if (i == charArray.length - 1) &#123;</span><br><span class="line">					throw new UnsupportDecodeException();</span><br><span class="line">				&#125;</span><br><span class="line">				if (charArray[i + 1] == &apos;\\&apos;) &#123;</span><br><span class="line">					sb.append(&quot;\\&quot;);</span><br><span class="line">					i++;</span><br><span class="line">				&#125; else if (charArray[i + 1] == &apos;u&apos;) &#123;</span><br><span class="line">					if (i &gt;= charArray.length - 5 || !isHexChar(charArray[i + 2])</span><br><span class="line">							 || !isHexChar(charArray[i + 3]) || !isHexChar(charArray[i + 4])</span><br><span class="line">							 || !isHexChar(charArray[i + 5])) &#123;</span><br><span class="line">						throw new UnsupportDecodeException();</span><br><span class="line">					&#125;</span><br><span class="line">					String hexInt = &quot;&quot; + charArray[i + 2] + charArray[i + 3] + charArray[i + 4] + charArray[i + 5];</span><br><span class="line">					char v = (char) Integer.valueOf(hexInt, 16).intValue();</span><br><span class="line">					sb.append(v);</span><br><span class="line">					i += 5;</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				sb.append(c);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return sb.toString();</span><br><span class="line">	&#125;</span><br><span class="line">	private static boolean isHexChar(char c) &#123;</span><br><span class="line">		if (c &gt;= &apos;0&apos; &amp;&amp; c &lt;= &apos;9&apos;) return true;</span><br><span class="line">		if (c &gt;= &apos;a&apos; &amp;&amp; c &lt;= &apos;f&apos;) return true;</span><br><span class="line">		if (c &gt;= &apos;A&apos; &amp;&amp; c &lt;= &apos;F&apos;) return true;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line">	private static String charToUnicodeString(char c, boolean encodeAscii) &#123;</span><br><span class="line">		if (c &lt; 0x80 &amp;&amp; !encodeAscii) &#123;</span><br><span class="line">			if (c == &apos;\\&apos;) &#123;</span><br><span class="line">				return &quot;\\\\&quot;;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				return c + &quot;&quot;;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		String hex = Integer.toHexString(c);</span><br><span class="line">		if (c &lt; 0x10) &#123;</span><br><span class="line">			return &quot;\\u000&quot; + hex;</span><br><span class="line">		&#125; else if (c &lt; 0x100) &#123;</span><br><span class="line">			return &quot;\\u00&quot; + hex;</span><br><span class="line">		&#125; else if (c &lt; 0x1000) &#123;</span><br><span class="line">			return &quot;\\u0&quot; + hex;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			return &quot;\\u&quot; + hex;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	public static class UnsupportDecodeException extends Exception &#123;</span><br><span class="line">		private static final long serialVersionUID = 1L;</span><br><span class="line"></span><br><span class="line">		public UnsupportDecodeException() &#123;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	public static void main(String[] args) throws UnsupportDecodeException &#123;</span><br><span class="line">		System.out.println(encode(&quot;中abcµ&quot;, true)); // \u4e2d</span><br><span class="line">		System.out.println(&quot;\u4e2d&quot;); // 不需要转换，jvm自动处理</span><br><span class="line">		System.out.println(decode(&quot;\\u4e2d&quot;)); // 中</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="UTF-8和UTF-8MB4关系"><a href="#UTF-8和UTF-8MB4关系" class="headerlink" title="UTF-8和UTF-8MB4关系"></a>UTF-8和UTF-8MB4关系</h3><p>Unicode字符集，实际上有两个系列，分为2个字节和4个字节的两种，2个字节的Unicode字符集称为<code>UCS-2</code>（通常说的Unicode大都是<code>UCS-2</code>），4个字节的Unicode字符集称为<code>UCS-4</code>，<code>UCS-4</code>是<code>UCS-2</code>的超集。<code>UCS-2</code>可容纳65536个码位，<code>UCS-4</code>目前可用码位分为了17个平面（每个平面可容纳65536个码位，即一共1114112个码位，第1个平面被称为基本多语言平面，即<code>UCS-2</code>的字符集，其他16个平面统称为辅助平面），它为现有的所有文字和符号以及将来可能出现的字符都指定（或预留）了一个唯一的数字编码。</p>
<p><strong>UTF-8MB3</strong></p>
<p>通常所说的UTF-8（即狭义上的UTF-8），实际上是UTF-8MB3，一个字符占1-3个字节（只有编码规则的前三行），它是以<code>UCS-2</code>为字符集的编码规则。</p>
<p><strong>UTF-8MB4</strong></p>
<p>除了UTF-8MB3以外，还存在UTF-8MB4编码，一个字符占1-4个字节，可以表示超过65536个字符（没能达到1114112个，仅能表示20多万个），因此有能力表示<code>UCS-4</code>中的部分字符。</p>
<h3 id="UTF-8、UTF-16和GBK、GB2312的区别"><a href="#UTF-8、UTF-16和GBK、GB2312的区别" class="headerlink" title="UTF-8、UTF-16和GBK、GB2312的区别"></a>UTF-8、UTF-16和GBK、GB2312的区别</h3><p>UFT-8、UTF-16、GBK、GB2312都能编码汉字，但在汉字的支持数量上、以及字符集上有所差异。</p>
<p><strong>GB2312</strong></p>
<p>GB2312是由国内制定，在ASCII码的基础上扩充汉字编码制定的字符集与编码规则，共收录了6763个常用汉字，英文占一个字节，汉字占两个字节。</p>
<p><strong>GBK</strong></p>
<p>GBK编码，扩展了GB2312编码收录的字符数量，并沿用了GB2312的码位（是GB2312编码的超集），收录了21003个汉字，包含<code>UCS-2</code>汉字区的全部汉字。英文占一个字节，汉字占两个字节，向下兼容GB2312编码。</p>
<p><strong>GB18030</strong></p>
<p>GB18030编码，在GBK的基础上再次扩充了汉字字符数量，并增加了少数民族字符，收录了70244个汉字。与GB2312-1980完全向后兼容，与GBK基本兼容，并支持Unicode的所有码位。编码包含三种长度：单子节ASCII，双字节的GBK（略带扩展）、以及用于填补所有Unicode码位的四字节UTF区块（Unicode码位数1114112少于GB18030的161668个码位）。</p>
<p><strong>BIG5</strong></p>
<p>BIG5编码是台湾制定的基于ASCII扩充的中文编码规则，但其与GB2312字符集码位不是一个体系。</p>
<p><strong>UTF-8</strong></p>
<p>就像GBK编码一样，各国都对ASCII进行扩展定义了自己的编码，不利于国际间文件交换。Unicode编码是在这种背景下，国际标准组织将世界各国语言都纳入了编码体系，形成的一个字符集。</p>
<p>前面说过Unicode有<code>UCS-2</code>和<code>UCS-4</code>两种，<code>UCS-2</code>汉字编码范围在U+4E00-9FA5，包含20928个汉字（仅汉字区），容纳中日韩（CJK）统一编码的汉字共27484个（日语区和韩语区也有部分日语韩语常用汉字）。而<code>UCS-4</code>的第1个平面即是<code>UCS-2</code>的码位，所以包含的汉字数量必然大于<code>UCS-2</code>（具体值没找到资料）。</p>
<p>UTF-8MB3编码，以<code>UCS-2</code>字符集为基础的编码，而UTF-8MB4已经超过<code>UCS-2</code>字符集，包含部分<code>UCS-4</code>字符。</p>
<p><strong>UTF-16</strong></p>
<p>UTF-16与UTF-8一样，是众多UTF(UCS Transfer Format)标准中的一个，它是以<code>UCS-4</code>为字符集的编码规则，有2个字节和4个字节两种长度，2个字节的用于编码“基本多语言平面中的字符”（即<code>UCS-2</code>部分），4个字符编码其余辅助平面的字符。</p>
<p>UTF-8和UTF-16算是一个字符集体系的编码，GB系列算一个字符集体系的编码。</p>
<h2 id="Java中的内存编码"><a href="#Java中的内存编码" class="headerlink" title="Java中的内存编码"></a>Java中的内存编码</h2><p>Java内存唯一使用的编码是<code>Unicode</code>（<code>UCS-2</code>字符集，注意是内存编码，不是运行时与用户交互的编码）。平时调用的<code>String.getBytes()</code>方法，实际上就是将内存中字符的码点按指定编码规则组织为bytes数组，同理，<code>new String(bytes)</code>方法，即是将bytes数组按指定编码规则翻译成码点存在内存中。</p>
<h3 id="前端输入的emoji字符由UTF-8MB4编码，传到后端Java是如何处理的呢？"><a href="#前端输入的emoji字符由UTF-8MB4编码，传到后端Java是如何处理的呢？" class="headerlink" title="前端输入的emoji字符由UTF-8MB4编码，传到后端Java是如何处理的呢？"></a>前端输入的emoji字符由UTF-8MB4编码，传到后端Java是如何处理的呢？</h3><p>Java采取的策略是将其转为两个UTF-8MB3字符。具体转换过程如下：</p>
<ol>
<li><strong>首先读取字节，如以”😭”表情为例，读取到如下字节（负数已处理为正数）</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">240       159       152       173</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>二进制表示为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bytes[0]  bytes[1]  bytes[2]  bytes[3]</span><br><span class="line">‭11110000‬  ‭10011111‬  ‭10011000‬  ‭10101101‬</span><br></pre></td></tr></table></figure>

<p>由于值是以utf8mb4编码的，观察二进制值，符合如下模板格式，抽离模板后即可得到码点值的二进制代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">11110xxx  10xxxxxx  10xxxxxx  10xxxxxx    二进制值模板</span><br><span class="line">     000    011111    011000‬    101101‬    抽离模板后得到码点值的二进制表示</span><br></pre></td></tr></table></figure>

<p>上述码点值计算的过程可以用如下公式表示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">codePoint = ((bytes[0] &amp; 0x7) &lt;&lt; 18) + ((bytes[1] &amp; 0x3f) &lt;&lt; 12) + (bytes[2] &amp; 0x3f) &lt;&lt; 6) + (bytes[3] &amp; 0x3f)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>将UTF-8MB4字符拆成为两个字符</strong><br>步骤如下</li>
</ol>
<ul>
<li><p>先将码点值减掉(2^16)，并去掉第1位</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val = codePoint - (1 &lt;&lt; 16)</span><br><span class="line">val = val &amp; 0xFFFFF;</span><br><span class="line">     000    001111    011000    101101        计算后的二进制值</span><br><span class="line">      00    001111    011000    101101        去掉第1位</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后填充到固定转化模板（后面解释），得到两个三字节的UTF-8编码值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">11101101  1010xxxx  10xxxxxx    11101101  1011xxxx  10xxxxxx    固定转化模板</span><br><span class="line">11101101  10100000  10111101    11101101  10111000  10101101    填充后二进制值</span><br></pre></td></tr></table></figure>
</li>
<li><p>再计算新的码点（此时是两个三字节的UTF-8编码值，所以有如下模板）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1110xxxx  10xxxxxx  10xxxxxx    1110xxxx  10xxxxxx  10xxxxxx    三字节格式二进制值模板</span><br><span class="line">    1101    100000    111101        1101    111000    101101    抽离模板后值</span><br></pre></td></tr></table></figure>
</li>
<li><p>整理二进制位，得到两个新的Unicode码点：D83D, DE2D</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">11011000  00111101              11011110  00101101</span><br><span class="line">D83D                            DE2D</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>上面的转换步骤稍加整理后，可以得到公式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">新码点的值计算：</span><br><span class="line">val = ((bytes[0] &amp; 0x7) &lt;&lt; 18) + ((bytes[1] &amp; 0x63) &lt;&lt; 12) + (bytes[2] &amp; 0x63) &lt;&lt; 6) + (bytes[3] &amp; 0x63) - (1 &lt;&lt; 16)</span><br><span class="line">val = val &amp; 0xFFFFF</span><br><span class="line">// 110110xxxxxxxxxx 110111xxxxxxxxxx    来自固定转化模板的值</span><br><span class="line">// 0b110110 = 54</span><br><span class="line">// 54 &lt;&lt; 10 = 0xD800</span><br><span class="line">codePointN[0] = (val &gt;&gt;&gt; 10) + 0xD800</span><br><span class="line">// 0b110111 = 55</span><br><span class="line">// 55 &lt;&lt; 10 = 0xDC00</span><br><span class="line">codePointN[1] = (val &amp; 0x3FF) + 0xDC00</span><br></pre></td></tr></table></figure>

<p><strong>拆分字符时使用的固定转化模板为什么是这个？</strong></p>
<p><strong>其一</strong> 3字节UTF-8，固定了一些位</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1110xxxx  10xxxxxx  10xxxxxx    1110xxxx  10xxxxxx  10xxxxxx</span><br></pre></td></tr></table></figure>

<p><strong>其二</strong> 新码点不能与UTF-8MB3冲突，所以选用为UTF-16永久保留不映射的码点区间(<code>0xD800-0xDBFF</code>和<code>0xDC00-0xDFFF</code>)作为新值所在的区间（两个区间的区别只是与大端和小端的规定有关）<br>因此又可以固定剩余几位（<code>D8</code>二进制为‭<code>11011000</code>‬，<code>DB</code>二进制为‭<code>11011011</code>‬，<code>DC</code>二进制为<code>‭11011100</code>‬，<code>DF</code>二进制为<code>‭11011111</code>‬）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11101101  1010xxxx  10xxxxxx    11101101  1011xxxx  10xxxxxx</span><br></pre></td></tr></table></figure>

<p><strong>关于码点值减掉(2^16)</strong></p>
<p>参见JDK中的<code>java.lang.Character#highSurrogate</code>方法，这是用于计算高位值的方法</p>
<p>相应的，低位值计算方法见<code>java.lang.Character#lowSurrogate</code>方法</p>
<p>它们被调用的位置见<code>sun.nio.cs.UTF_8.Decoder#decode</code>方法</p>
<h3 id="关于内存编码处理的测试代码"><a href="#关于内存编码处理的测试代码" class="headerlink" title="关于内存编码处理的测试代码"></a>关于内存编码处理的测试代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">public static void main(String[] args) throws IOException, UnsupportDecodeException &#123;</span><br><span class="line">	byte[] bytes = new byte[10];</span><br><span class="line">	int read = System.in.read(bytes);</span><br><span class="line">	System.out.println(&quot;读取byte如下 --&gt; &quot;);</span><br><span class="line">	for (int i = 0; i &lt; read; i++) &#123; // 最后一个打印10为回车键</span><br><span class="line">		System.out.println(bytes[i] &amp; 0xff);</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(&quot;读取内容如下 --&gt; &quot;);</span><br><span class="line">	System.out.println(new String(bytes, 0, read));</span><br><span class="line">	System.out.println(&quot;-----------------&quot;);</span><br><span class="line">	int val = ((bytes[0] &amp; 0x7) &lt;&lt; 18) + ((bytes[1] &amp; 0x3f) &lt;&lt; 12) + ((bytes[2] &amp; 0x3f) &lt;&lt; 6) + (bytes[3] &amp; 0x3f) - (1 &lt;&lt; 16);</span><br><span class="line">	val = val &amp; 0xFFFFF;</span><br><span class="line">	int high = (val &gt;&gt;&gt; 10) + 0xD800;</span><br><span class="line">	int low = (val &amp; 0x3FF) + 0xDC00;</span><br><span class="line">	System.out.println(Integer.toHexString((high &amp; 0xffff) &gt;&gt; 8));</span><br><span class="line">	System.out.println(Integer.toHexString(high &amp; 0xff));</span><br><span class="line">	System.out.println(Integer.toHexString((low &amp; 0xffff) &gt;&gt; 8));</span><br><span class="line">	System.out.println(Integer.toHexString(low &amp; 0xff));</span><br><span class="line">	System.out.println(&quot;-----------------&quot;);</span><br><span class="line"></span><br><span class="line">	System.out.println();</span><br><span class="line">	System.out.println(&quot;重复输入一次，验证unicode编码&quot;);</span><br><span class="line">	Scanner scanner = new Scanner(System.in);</span><br><span class="line">	if (scanner.hasNext()) &#123;</span><br><span class="line">		String next = scanner.next();</span><br><span class="line">		System.out.println();</span><br><span class="line">		System.out.println(encode(next, true));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="MySQL中的编码"><a href="#MySQL中的编码" class="headerlink" title="MySQL中的编码"></a>MySQL中的编码</h2><p>了解了码点以及Java编码转化的本质后，应该能够明白MySQL中，如果客户端与服务器端编码不同，首先字符集就已经不同，那么存入数据库之后出现乱码也就不难理解了。</p>
<p>在MySQL数据库中，新建数据库的时候会要求选择字符集和排序规则，这里的字符集就是本文所说的编码规则，而排序规则，则是在SQL查询中对文本排序时的排序依据（可以类比为Java中<code>java.util.Comparator</code>的实现），比如：是按ASCII码排序、还是按汉字拼音首字母排序、或者按德语字母顺序排序、或者排序时大小写不同是否看成同一个字符。</p>
<p>以常用的<code>utf8mb4_general_ci</code>、<code>utf8mb4_unicode_ci</code>和<code>utf8mb4_bin</code>为例：<code>utf8mb4_unicode_ci</code>针对各语言做了比较复杂的处理，在各语言中的排序更加准确（主要是在德语、法语等一部分语言中有影响，对中文、英文没影响），排序速度较慢；<code>utf8mb4_general_ci</code>大小写不敏感，相比<code>utf8mb4_unicode_ci</code>排序速度也更快，<code>utf8mb4_bin</code>大小写敏感。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://page.uetty.com/2020/02/13/character-set-encoding/" data-id="ck71vzlej0003swukx0qhzd72" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/encoding/">encoding</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-gitlab-api" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/08/gitlab-api/" class="article-date">
  <time datetime="2020-01-08T11:02:24.000Z" itemprop="datePublished">2020-01-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/08/gitlab-api/">Gitlab Api</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="认证-官网文档地址"><a href="#认证-官网文档地址" class="headerlink" title="认证(官网文档地址)"></a>认证(<a href="https://docs.gitlab.com/ee/api/README.html#authentication" target="_blank" rel="noopener">官网文档地址</a>)</h2><p>四种方式</p>
<ol>
<li>OAuth2 tokens</li>
<li>Personal access tokens</li>
<li>Session cookie</li>
<li>GitLab CI job token (Specific endpoints only)</li>
</ol>
<h3 id="OAuth2-tokens"><a href="#OAuth2-tokens" class="headerlink" title="OAuth2 tokens"></a>OAuth2 tokens</h3><p><code>curl https://gitlab.example.com/api/v4/projects?access_token=OAUTH-TOKEN</code></p>
<p>或</p>
<p><code>curl --header &quot;Authorization: Bearer OAUTH-TOKEN&quot; https://gitlab.example.com/api/v4/projects</code></p>
<h3 id="Personal-access-tokens"><a href="#Personal-access-tokens" class="headerlink" title="Personal access tokens"></a>Personal access tokens</h3><p><code>curl https://gitlab.example.com/api/v4/projects?private_token=&lt;your_access_token&gt;</code></p>
<p>或</p>
<p><code>curl --header &quot;Private-Token: &lt;your_access_token&gt;&quot; https://gitlab.example.com/api/v4/projects</code></p>
<p>或</p>
<p><code>curl --header &quot;Authorization: Bearer &lt;your_access_token&gt;&quot; https://gitlab.example.com/api/v4/projects</code></p>
<h2 id="响应状态码-官网文档地址"><a href="#响应状态码-官网文档地址" class="headerlink" title="响应状态码(官网文档地址)"></a>响应状态码(<a href="https://docs.gitlab.com/ee/api/README.html#status-codes" target="_blank" rel="noopener">官网文档地址</a>)</h2><p>成功的状态码主要会有三种，失败的情况有多种，具体官网文档查看</p>
<table>
<thead>
<tr>
<th align="center">状态码</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>200</code></td>
<td align="center">对于<code>GET</code>,<code>PUT</code>或<code>DELETE</code>请求，成功时返回的响应头中的状态码，并且返回的响应体包含json数据</td>
</tr>
<tr>
<td align="center"><code>201</code></td>
<td align="center">对于<code>POST</code>请求，成功时返回的响应头中的状态码，并且返回的响应体包含json数据</td>
</tr>
<tr>
<td align="center"><code>204</code></td>
<td align="center">表示服务器成功执行了请求，但返回的响应体无内容（即无响应体部分）</td>
</tr>
</tbody></table>
<h2 id="分页-官网文档地址"><a href="#分页-官网文档地址" class="headerlink" title="分页(官网文档地址)"></a>分页(<a href="https://docs.gitlab.com/ee/api/README.html#pagination" target="_blank" rel="noopener">官网文档地址</a>)</h2><p>提供两种分页方式</p>
<ol>
<li>键集分页（性能原因考虑，官网推荐这种方式）</li>
<li>偏移分页</li>
</ol>
<h3 id="偏移分页"><a href="#偏移分页" class="headerlink" title="偏移分页"></a>偏移分页</h3><p>请求参数控制分页</p>
<table>
<thead>
<tr>
<th align="center">参数名</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>page</code></td>
<td align="center">页码（默认1）</td>
</tr>
<tr>
<td align="center"><code>per_page</code></td>
<td align="center">每页数量（默认20，最大100）</td>
</tr>
</tbody></table>
<h3 id="键集分页"><a href="#键集分页" class="headerlink" title="键集分页"></a>键集分页</h3><p>键集分页可以更有效地检索页面，并且与基于偏移的分页不同，运行时与集合的大小无关（翻译自官网）。</p>
<p>请求参数控制分页</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>pagination</code></td>
<td><code>keyset</code> (为了允许键集分页而设定)</td>
</tr>
<tr>
<td><code>per_page</code></td>
<td>每页数量（默认20，最大100）</td>
</tr>
</tbody></table>
<p>例（<strong>官网文档案例</strong>）：</p>
<p>请求（官网文档上<code>--request PUT</code>应该是错的，实际请求应该去掉）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --request PUT --header &quot;PRIVATE-TOKEN: &lt;your_access_token&gt;&quot; &quot;https://gitlab.example.com/api/v4/projects?pagination=keyset&amp;per_page=50&amp;order_by=id&amp;sort=asc&quot;</span><br></pre></td></tr></table></figure>

<p>响应信息（<strong>官网文档案例</strong>中响应中包含到下一页的链接）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">...</span><br><span class="line">Link: &lt;https://gitlab.example.com/api/v4/projects?pagination=keyset&amp;per_page=50&amp;order_by=id&amp;sort=asc&amp;id_after=42&gt;; rel=&quot;next&quot;</span><br><span class="line">Status: 200 OK</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><strong>按官网文档介绍</strong>，下一页链接中包含额外的过滤器<code>id_after</code>，过滤器类型取决于<code>order_by</code>选项，当没有更多的记录时，响应头不包含<code>Link</code>字段。<code>rel=&quot;next&quot;</code>，并不是唯一的情况，还可能有<code>rel=&quot;first&quot;</code>、rel=”last”，<code>Link</code>字段中也可能同时存在多个<code>&lt;....&gt;; rel=&quot;...&quot;</code>，解码时需要注意。</p>
<p>仅对特定的资源支持键集分页(实际上应该不止这个接口)</p>
<table>
<thead>
<tr>
<th>Resource</th>
<th>Order</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://docs.gitlab.com/ee/api/projects.html" target="_blank" rel="noopener">/api/v4/projects</a></td>
<td><code>order_by=id</code> only</td>
</tr>
</tbody></table>
<p><strong>实际验证之后发现</strong>，与文档描述是不一样的，响应头<code>Link</code>字段中的链接增加的参数不是<code>order_by</code>字段，而是<code>page=2</code>参数，以及增加了<code>/api/v4/projects</code>接口的其他参数，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">...</span><br><span class="line">Link: &lt;https://gitlab.com/api/v4/projects?membership=false&amp;order_by=id&amp;owned=false&amp;page=2&amp;pagination=keyset&amp;per_page=50&amp;repository_checksum_failed=false&amp;simple=false&amp;sort=asc&amp;starred=false&amp;statistics=false&amp;wiki_checksum_failed=false&amp;with_custom_attributes=false&amp;with_issues_enabled=false&amp;with_merge_requests_enabled=false&gt;; rel=&quot;next&quot;, &lt;https://gitlab.com/api/v4/projects?membership=false&amp;order_by=id&amp;owned=false&amp;page=1&amp;pagination=keyset&amp;per_page=50&amp;repository_checksum_failed=false&amp;simple=false&amp;sort=asc&amp;starred=false&amp;statistics=false&amp;wiki_checksum_failed=false&amp;with_custom_attributes=false&amp;with_issues_enabled=false&amp;with_merge_requests_enabled=false&gt;; rel=&quot;first&quot;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>可能是官网文档较长时间没更新了吧</p>
<h3 id="分页响应头"><a href="#分页响应头" class="headerlink" title="分页响应头"></a>分页响应头</h3><p>分页响应头中包含下面字段</p>
<table>
<thead>
<tr>
<th>响应头</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>X-Total</code></td>
<td>结果总数量（并不一定返回，官网介绍出于性能原因考虑结果集大于1000时就不会返回，实际上不返回的情况可能更多）</td>
</tr>
<tr>
<td><code>X-Total-Pages</code></td>
<td>结果总页数（并不一定返回，官网介绍出于性能原因考虑结果集大于1000时就不会返回，实际上不返回的情况可能更多）</td>
</tr>
<tr>
<td><code>X-Per-Page</code></td>
<td>每页多少条</td>
</tr>
<tr>
<td><code>X-Page</code></td>
<td>当期所在页</td>
</tr>
<tr>
<td><code>X-Next-Page</code></td>
<td>下一页</td>
</tr>
<tr>
<td><code>X-Prev-Page</code></td>
<td>前一页</td>
</tr>
</tbody></table>
<p>分页这里还是有不少坑的，实际表现与官方文档描述诸多不符</p>
<p>键集分页响应头中另外还包含如下字段</p>
<table>
<thead>
<tr>
<th>响应头</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>Link</code></td>
<td>可能包含下一页的请求地址、上一页的请求地址、第一页的请求地址、最后一页的请求地址。仅仅是可能包含，不一定包含，比如，当结果总条数特别多时，就不会包含最后一页的请求地址（可能是性能原因考虑，gitlab服务器上实际上没有查询完所有结果就响应了）；当页面位于第一页时，不会包含上一页的请求地址。</td>
</tr>
</tbody></table>
<h2 id="频率限制-官网文档地址"><a href="#频率限制-官网文档地址" class="headerlink" title="频率限制(官网文档地址)"></a>频率限制(<a href="https://docs.gitlab.com/ee/security/rate_limits.html" target="_blank" rel="noopener">官网文档地址</a>)</h2><p>实际上频率限制这一块文档，基本是面向2B客户（即在自己服务器上部署gitlab的客户）的，API查询从官网文档中得不到多少信息。<code>Rack Attach</code>章节，可能会有些许借鉴意义，它旨在限制来自大量请求的IP地址的请求。</p>
<h3 id="Rack-Attach"><a href="#Rack-Attach" class="headerlink" title="Rack Attach"></a>Rack Attach</h3><p>API查询的请求头中返回的字段会包含如下几个(<a href="https://docs.gitlab.com/ee/user/gitlab_com/index.html#haproxy-api-throttle" target="_blank" rel="noopener">此处官网链接</a>)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RateLimit-Limit: 600</span><br><span class="line">RateLimit-Observed: 6</span><br><span class="line">RateLimit-Remaining: 594</span><br><span class="line">RateLimit-Reset: 1563325137</span><br><span class="line">RateLimit-ResetTime: Wed, 17 Jul 2019 00:58:57 GMT</span><br></pre></td></tr></table></figure>

<p>其中<code>RateLimit-Remaining</code>表示到重置时间<code>RateLimit-Reset</code>为止，能进行多少次请求</p>
<p>对于某些受保护的接口，每分钟超过10次的情况下，会触发code <code>429</code>，并且响应头中会包含如下信息。表明当前IP被服务器限制请求，可在60秒后重新发起请求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Retry-After: 60</span><br></pre></td></tr></table></figure>

<p>默认情况下，受保护的接口有</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">default[&apos;gitlab&apos;][&apos;gitlab-rails&apos;][&apos;rack_attack_protected_paths&apos;] = [</span><br><span class="line">  &apos;/users/password&apos;,</span><br><span class="line">  &apos;/users/sign_in&apos;,</span><br><span class="line">  &apos;/api/#&#123;API::API.version&#125;/session.json&apos;,</span><br><span class="line">  &apos;/api/#&#123;API::API.version&#125;/session&apos;,</span><br><span class="line">  &apos;/users&apos;,</span><br><span class="line">  &apos;/users/confirmation&apos;,</span><br><span class="line">  &apos;/unsubscribes/&apos;,</span><br><span class="line">  &apos;/import/github/personal_access_token&apos;,</span><br><span class="line">  &apos;/admin/session&apos;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="设置项目的请求频率"><a href="#设置项目的请求频率" class="headerlink" title="设置项目的请求频率"></a>设置项目的请求频率</h3><p>这一块与API请求无关，是2B客户设置请求频率相关的内容，可以在<a href="https://docs.gitlab.com/ee/user/admin_area/settings/user_and_ip_rate_limits.html" target="_blank" rel="noopener">User and IP rate limits</a>和<a href="https://docs.gitlab.com/ee/user/admin_area/settings/rate_limits_on_raw_endpoints.html" target="_blank" rel="noopener">Rate limits on raw endpoints</a>章节中查看</p>
<h2 id="查询相关接口官网文档地址"><a href="#查询相关接口官网文档地址" class="headerlink" title="查询相关接口官网文档地址"></a>查询相关接口<a href="https://docs.gitlab.com/ee/api/README.html#status-codes" target="_blank" rel="noopener">官网文档地址</a></h2><h3 id="search接口"><a href="#search接口" class="headerlink" title="search接口"></a>search接口</h3><p>全局（不限项目project/不限组织group）search接口路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/api/v4/search</span><br></pre></td></tr></table></figure>

<p>参数</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>scope</code></td>
<td>搜索范围</td>
</tr>
<tr>
<td><code>search</code></td>
<td>搜索的字符串</td>
</tr>
</tbody></table>
<p>scope取值</p>
<table>
<thead>
<tr>
<th>取值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>projects</td>
<td>从项目名称和项目描述中搜索</td>
</tr>
<tr>
<td>merge_requests</td>
<td>从merge记录搜索</td>
</tr>
<tr>
<td>issues</td>
<td>从issue搜索</td>
</tr>
<tr>
<td>milestones</td>
<td>从发布的里程碑版本搜索</td>
</tr>
<tr>
<td>snippet_titles</td>
<td>从代码片（与项目没有关系，是另一种与项目同级别的产品）标题搜索</td>
</tr>
<tr>
<td>snippet_blobs</td>
<td>从代码片的内容搜索</td>
</tr>
<tr>
<td>wiki_blobs</td>
<td>从项目的文件内容搜索（在gitlab官方代码服务器上没法使用，需要在自己服务器部署gitlab服务器，并安装elasticsearch才能使用），在官网描述中看不出wiki_blobs与blobs有何区别</td>
</tr>
<tr>
<td>commits</td>
<td>从commit中搜索（在gitlab官方代码服务器上没法使用，需要在自己服务器部署gitlab服务器，并安装elasticsearch才能使用）</td>
</tr>
<tr>
<td>blobs</td>
<td>从项目的文件内容搜索（在gitlab官方代码服务器上没法使用，需要在自己服务器部署gitlab服务器，并安装elasticsearch才能使用）</td>
</tr>
<tr>
<td>users</td>
<td>从用户名搜索</td>
</tr>
</tbody></table>
<h3 id="projects接口"><a href="#projects接口" class="headerlink" title="projects接口"></a>projects接口</h3><p>接口路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/api/v4/projects</span><br></pre></td></tr></table></figure>

<p>参数</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>类型</th>
<th>是否必传</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>archived</code></td>
<td>boolean</td>
<td>no</td>
<td>过滤打包状态</td>
</tr>
<tr>
<td><code>visibility</code></td>
<td>string</td>
<td>no</td>
<td>过滤可见范围 <code>public</code>, <code>internal</code>, <code>private</code></td>
</tr>
<tr>
<td><code>order_by</code></td>
<td>string</td>
<td>no</td>
<td>排序依据字段，可以为<code>id</code>, <code>name</code>, <code>path</code>, <code>created_at</code>, <code>updated_at</code>, <code>last_activity_at</code> 字段，默认是 <code>created_at</code></td>
</tr>
<tr>
<td><code>sort</code></td>
<td>string</td>
<td>no</td>
<td>排序，<code>asc</code> / <code>desc</code> ，默认是 <code>desc</code></td>
</tr>
<tr>
<td><code>search</code></td>
<td>string</td>
<td>no</td>
<td>搜索字符串</td>
</tr>
<tr>
<td><code>simple</code></td>
<td>boolean</td>
<td>no</td>
<td>true时，只返回少量简单字段</td>
</tr>
<tr>
<td><code>owned</code></td>
<td>boolean</td>
<td>no</td>
<td>过滤，仅当前用户拥有的项目</td>
</tr>
<tr>
<td><code>membership</code></td>
<td>boolean</td>
<td>no</td>
<td>过滤，仅当前用户所属的项目</td>
</tr>
<tr>
<td><code>starred</code></td>
<td>boolean</td>
<td>no</td>
<td>过滤，仅当前用户加星的项目</td>
</tr>
<tr>
<td><code>statistics</code></td>
<td>boolean</td>
<td>no</td>
<td>包括项目统计</td>
</tr>
<tr>
<td><code>with_custom_attributes</code></td>
<td>boolean</td>
<td>no</td>
<td>过滤，包含<a href="https://docs.gitlab.com/ee/api/custom_attributes.html" target="_blank" rel="noopener">自定义属性 custom_attributes</a>设置（仅管理员）</td>
</tr>
<tr>
<td><code>with_issues_enabled</code></td>
<td>boolean</td>
<td>no</td>
<td>过滤，根据issues_enabled值</td>
</tr>
<tr>
<td><code>with_merge_requests_enabled</code></td>
<td>boolean</td>
<td>no</td>
<td>过滤，根据merge_requests_enabled值</td>
</tr>
<tr>
<td><code>with_programming_language</code></td>
<td>string</td>
<td>no</td>
<td>过滤，按编程语言过滤</td>
</tr>
<tr>
<td><code>wiki_checksum_failed</code></td>
<td>boolean</td>
<td>no</td>
<td>wiki校验值计算失败的项目(<a href="https://about.gitlab.com/pricing/" target="_blank" rel="noopener">GitLab Premium</a> 11.2中的<a href="https://gitlab.com/gitlab-org/gitlab/merge_requests/6137" target="_blank" rel="noopener">介绍</a>)</td>
</tr>
<tr>
<td><code>repository_checksum_failed</code></td>
<td>boolean</td>
<td>no</td>
<td>repository校验值计算失败的项目(<a href="https://about.gitlab.com/pricing/" target="_blank" rel="noopener">GitLab Premium</a> 11.2中的<a href="https://gitlab.com/gitlab-org/gitlab/merge_requests/6137" target="_blank" rel="noopener">介绍</a>)</td>
</tr>
<tr>
<td><code>min_access_level</code></td>
<td>integer</td>
<td>no</td>
<td>过滤，仅当前用户的 <a href="https://docs.gitlab.com/ee/api/members.html" target="_blank" rel="noopener">最低访问权限级别</a></td>
</tr>
<tr>
<td><code>id_after</code></td>
<td>integer</td>
<td>no</td>
<td>过滤，限制为ID大于指定ID的项目</td>
</tr>
<tr>
<td><code>id_before</code></td>
<td>integer</td>
<td>no</td>
<td>过滤，限制为ID小于指定ID的项目</td>
</tr>
</tbody></table>
<p>返回值中有两个需要注意的参数<code>repository_access_level</code>和<code>visibility</code>，只有<code>repository_access_level</code>参数值为<code>enabled</code>且<code>visibility</code>参数值为<code>public</code>时才可以clone该仓库</p>
<p>该接口，经身份验证的用户和未经身份验证的用户均可使用，但未经身份验证的用户响应内容中的信息会更少，与<code>simple=true</code>的时候相同。</p>
<p>当请求中包含自定义属性时，请求url传参如下所示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /api/v4/projects?custom_attributes[key]=value&amp;custom_attributes[other_key]=other_value</span><br></pre></td></tr></table></figure>

<p>阅读文档后，没怎么弄懂上面<code>/api/v4/projects</code>和<code>/api/v4/search?scope=projects</code>这两个接口有什么重要的区别，姑且认为它们是可以相互取代的，使用任意一个皆可。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://page.uetty.com/2020/01/08/gitlab-api/" data-id="ck5qhi075002pg0uks9hqbyjk" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/api/">api</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-source-bitcount" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/11/source-bitcount/" class="article-date">
  <time datetime="2019-12-11T11:11:49.000Z" itemprop="datePublished">2019-12-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/11/source-bitcount/">JDK中Integer.bitCount解析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>使用过Redis的人可能知道，Redis中给我们提供了统计二进制位数为1的位数量的指令<code>bitcout</code>，JDK中Integer类同样也给我们提供了该功能的方法<code>Integer.bigCount</code>，得益于此，我们很容易就能一窥该方法的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static int bitCount(int i) &#123;</span><br><span class="line">    // HD, Figure 5-2</span><br><span class="line">    i = i - ((i &gt;&gt;&gt; 1) &amp; 0x55555555);</span><br><span class="line">    i = (i &amp; 0x33333333) + ((i &gt;&gt;&gt; 2) &amp; 0x33333333);</span><br><span class="line">    i = (i + (i &gt;&gt;&gt; 4)) &amp; 0x0f0f0f0f;</span><br><span class="line">    i = i + (i &gt;&gt;&gt; 8);</span><br><span class="line">    i = i + (i &gt;&gt;&gt; 16);</span><br><span class="line">    return i &amp; 0x3f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码作为Integer类中比较有意思的一个方法，该方法利用了一个技巧：通过分割分配二进制位的方式，CPU可以实现一个指令同时计算多个数值。该方法的前四行都利用了该技巧。</p>
<p>NOTE：CPU要通过分配字节位的方式同时计算多个数值对，需要有一定的前提：由于每个数分配的字节位的长度有限，这就要求计算结果的二进制表示不能超出分配的位数。在当前问题上，显而易见是成立的：相加的两个数的最大值所占的二进制位数只有分配的二进制位的一半，结果值需要的二进制位必然不会超过分配的二进制位数。</p>
<h2 id="案例解析"><a href="#案例解析" class="headerlink" title="案例解析"></a>案例解析</h2><p>为了利于问题的解决，对计算二进制位1的数量这个问题，做一个等价转换：计算二进制位上每一位值的和。</p>
<p>以数字<code>‭1823425321‬</code>为例，二进制数值为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">‭0 1 1 0  1 1 0 0  1 0 1 0  1 1 1 1  0 1 0 0  0 0 1 1  0 0 1 0  1 0 0 1‬</span><br></pre></td></tr></table></figure>

<p><strong>1. 方法第一行</strong></p>
<p>将二进制的每1位都视为一个单独的数字，从左往右两个两个数字配对，形成16组二进制数相加，得到16个数值（2位二进制）。为了使结果是2位二进制数，相加前还需先给每个数前面补零。计算过程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">‭0 1  1 0  1 1  0 0  1 0  1 0  1 1  1 1  0 1  0 0  0 0  1 1  0 0  1 0  1 0  0 1‬     </span><br><span class="line">                                      ⇩  </span><br><span class="line">00   01   01   00   01   01   01   01   00   00   00   01   00   01   01   00</span><br><span class="line">                                      +</span><br><span class="line">01   00   01   00   00   00   01   01   01   00   00   01   00   00   00   01</span><br><span class="line">                                      ⇩</span><br><span class="line">01   01   10   00   01   01   10   10   01   00   00   10   00   01   01   01</span><br></pre></td></tr></table></figure>

<p>上述计算过程用代码表示如下（0x55555555的二进制值是0b_01010101010101010101010101010101）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = (i &amp; 0x55555555) + ((i &gt;&gt;&gt; 1) &amp; 0x55555555);</span><br></pre></td></tr></table></figure>

<p>公式中，<code>i &gt;&gt;&gt; 1</code>将偶数位变为了奇数位，<code>&amp; 0x55555555</code>则清空偶数位，结合起来之后<code>(i &amp; 0x55555555)</code>和<code>((i &gt;&gt;&gt; 1) &amp; 0x55555555)</code>就分别提取了奇数位和偶数位的值，分别以奇偶位为基构建了两组2位二进制数数组，两组数组相加，完成第1步计算。</p>
<p>认真的可能就会发现，不对啊，代码里分明是减法啊。实际上，第一行代码，用了另一个公式替代：对于2位二进制数n，1的个数c可用公式<code>c = n - (n &gt;&gt;&gt; 1)</code>计算得到。这个公式也很容易证明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">假设：2位二进制n = b1 * (2 ^ 1) + b0 * (2 ^ 0)，显然b1是n的第2位数，b0是n的第1位数</span><br><span class="line">那么：所证问题等价于证明 b1 + b0 = n - b1</span><br><span class="line">因为</span><br><span class="line">    n - b1 = b1 * (2 ^ 1) + b0 * (2 ^ 0) - b1</span><br><span class="line">           = b1 * 2 + b0 - b1</span><br><span class="line">           = b1 + b0</span><br><span class="line">所以问题得证</span><br></pre></td></tr></table></figure>

<p>新的公式的代码在计算指令上比旧的代码减少了一个指令。所以新的代码就变为了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = i - ((i &gt;&gt;&gt; 1) &amp; 0x55555555);</span><br></pre></td></tr></table></figure>

<p><strong>2. 方法第二行</strong></p>
<p>将二进制数每2位视为一个单独的数字，从左往右两个两个数字配对，形成8组二进制数相加，得到8个数值（4位二进制）。同样的，为了使结果是4位二进制数，相加前还得给每个数前面补零。计算过程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">01  01    10  00    01  01    10  10    01  00    00  10    00  01    01   01</span><br><span class="line">                                     ⇩  </span><br><span class="line">0001      0010      0001      0010      0001      0000      0000      0001</span><br><span class="line">                                     +</span><br><span class="line">0001      0000      0001      0010      0000      0010      0001      0001</span><br><span class="line">                                     ⇩</span><br><span class="line">0010      0010      0010      0100      0001      0010      0001      0010</span><br></pre></td></tr></table></figure>

<p>上述计算过程用代码表示如下（0x33333333的二进制值是0b_0011001100110011001100110011‬0011）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = (i &amp; 0x33333333) + ((i &gt;&gt;&gt; 2) &amp; 0x33333333);</span><br></pre></td></tr></table></figure>

<p>同样的，公式中，通过<code>(i&gt;&gt;&gt;2) &amp; 0x33333333</code>和<code>i &amp; 0x33333333</code>将<code>i</code>分为了相加的两部分，<code>0x33333333</code>起到了清空高2位数据的作用</p>
<p><strong>3. 方法第三行</strong></p>
<p>将二进制数的每4位视为一个单独的数字，从左往右两个两个数字配对，形成4组二进制数相加，得到4个数值（8位二进制）。同上所述，前面补零。计算过程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0010   0010   0010   0100   0001   0010   0001   0010</span><br><span class="line">                          ⇩</span><br><span class="line">00000010      00000010      00000001      00000001</span><br><span class="line">                          +</span><br><span class="line">00000010      00000100      00000010      00000010</span><br><span class="line">                          ⇩</span><br><span class="line">00000100      00000110      00000011      00000011</span><br></pre></td></tr></table></figure>

<p>上述计算过程用代码表示如下（0x0f0f0f0f的二进制值是0b_00001111000011110000111100001111‬）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = (i &amp; 0x0f0f0f0f) + ((i &gt;&gt;&gt; 4) &amp; 0x0f0f0f0f);</span><br></pre></td></tr></table></figure>

<p>在8位二进制数中，值为1的位数最大为8，仅需4个二进制位就能表示（PS：实际上，由<code>n &lt; 2 ^ (n / 2)</code>在<code>n &gt; 4</code>时均成立，可以得出：在n大于4时，n位二进制数的值为1的位数值m，只需不超过<code>n / 2</code>个二进制位即可表示）。这意味着相加后的结果值也不会超过4个二进制位，所以在计算中可以先不考虑高4位会对结果造成影响，清空高4位值的计算<code>&amp; 0x0f0f0f0f</code>可以在加法完成之后再进行，代码就可以简化成如下所示代码（比原来的代码少了一个指令）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = (i + (i &gt;&gt;&gt; 4)) &amp; 0x0f0f0f0f;</span><br></pre></td></tr></table></figure>

<p><strong>4. 方法第四行</strong></p>
<p>与前面一样，每8位视为一个单独的数字数字，相加之后得到2个16位二进制数值。计算过程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00000100    00000110     00000011    00000011</span><br><span class="line">                      ⇩</span><br><span class="line">0000000000000100         0000000000000011</span><br><span class="line">                      +</span><br><span class="line">0000000000000110         0000000000000011</span><br><span class="line">                      ⇩</span><br><span class="line">0000000000001010         0000000000000110</span><br></pre></td></tr></table></figure>

<p>代码表示如下（0x00ff00ff的二进制值是0b_00000000111111110000000011111111)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = (i &amp; 0x00ff00ff) + ((i &gt;&gt;&gt; 8) &amp; 0x00ff00ff);</span><br></pre></td></tr></table></figure>

<p>同理于第3步，加法计算中也可以先不用担心高8位对结果造成的影响直接计算即可，代码优化为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = (i + (i &gt;&gt;&gt; 8)) &amp; 0x00ff00ff;</span><br></pre></td></tr></table></figure>

<p>此外，<strong>对于32位的<code>Integer</code>，值为1的位数最大为32，也就是说最终结果仅需6个二进制位即可表示</strong>。而当前每个加数都已经达到8个二进制位，这种情况下，相加后的和的高8位的值即使不清空也不会影响最终结果的低6位的值。所以，可以<strong>将高位清空的任务留到所有计算完成后一并处理</strong>，省略<code>&amp; 0x00ff00ff</code>后代码简化为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = i + (i &gt;&gt;&gt; 8);</span><br></pre></td></tr></table></figure>

<p>而省略<code>&amp; 0x00ff00ff</code>后实际的计算过程是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00000100    00000110     00000011    00000011</span><br><span class="line">                      ⇩</span><br><span class="line">0000000000000100         0000011000000011</span><br><span class="line">                      +</span><br><span class="line">0000010000000110         0000001100000011</span><br><span class="line">                      ⇩</span><br><span class="line">0000010000001010         0000100100000110</span><br></pre></td></tr></table></figure>

<p><strong>5. 方法第五行</strong></p>
<p>同理于第4步，计算过程如下（以第4步中理论结果值为例）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0000000000001010         0000000000000110</span><br><span class="line">                    ⇩</span><br><span class="line">00000000000000000000000000001010</span><br><span class="line">                    +</span><br><span class="line">00000000000000000000000000000110</span><br><span class="line">                    ⇩</span><br><span class="line">00000000000000000000000000010000</span><br></pre></td></tr></table></figure>

<p>代码表示如下（0x0000ffff的二进制值是0b_00000000000000001111111111111111)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = (i &amp; 0x0000ffff) + ((i &gt;&gt;&gt; 16) &amp; 0x0000ffff);</span><br></pre></td></tr></table></figure>

<p>同理于第4步的优化，优化后代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = i + (i &gt;&gt;&gt; 16);</span><br></pre></td></tr></table></figure>

<p>同第4步一样的，贴出实际的计算过程如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0000010000001010         0000100100000110</span><br><span class="line">                    ⇩</span><br><span class="line">00000100000010100000100100000110</span><br><span class="line">                    +</span><br><span class="line">00000000000000000000010000001010</span><br><span class="line">                    ⇩</span><br><span class="line">00000100000010100000110100010000</span><br></pre></td></tr></table></figure>

<p><strong>6. 方法第六行</strong></p>
<p>前面第4步说过，为了精简代码的指令，将高位清空的任务留到所有计算完成后一并处理。在第4步和第5步中均遗留了未处理的高位数据，所以第6步将完成前面未完成的高位清空工作。第4步中已经分析过了，最终结果仅需6个二进制位即可表示，所以最后清空高26位的数据，计算过程如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00000100000010100000110100010000</span><br><span class="line">                ⇩</span><br><span class="line">00000000000000000000000000010000</span><br></pre></td></tr></table></figure>

<p>代码表示如下（0x0000003f的二进制值是0b_00000000000000000000000000111111）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = i &amp; 0x0000003f;</span><br></pre></td></tr></table></figure>

<p>所以最终的结果是<code>0b_10000</code>即16</p>
<p>可以看出来，<code>Integer.bitCount</code>方法在代码所耗费的指令上已经作了极尽的优化。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://page.uetty.com/2019/12/11/source-bitcount/" data-id="ck5qhi074002mg0uk0fz82vy1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-linux-cgroup-cpu" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/11/25/linux-cgroup-cpu/" class="article-date">
  <time datetime="2019-11-25T11:20:11.000Z" itemprop="datePublished">2019-11-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/25/linux-cgroup-cpu/">Linux限制进程CPU上限</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>要实现linux限制进程上限的功能，需要用到Cgroups技术，它的全程Linux Control Group，用于限制一个进程组能够使用的资源（CPU、内存、磁盘、网络带宽）上限，还能够对进程进行优先级设置，以及进行将进程挂起恢复的操作。</p>
<p>Cgroups给用户暴露出来的操作接口是文件系统，以目录和文件的方式组织在<code>/sys/fs/cgroup</code>路径下。</p>
<p>执行<code>ls /sys/fs/cgroup</code>命令可以看到如下文件列表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:$ ls /sys/fs/cgroup</span><br><span class="line">blkio  cpuacct      cpuset   freezer  memory   net_cls,net_prio  perf_event  rdma     unified</span><br><span class="line">cpu    cpu,cpuacct  devices  hugetlb  net_cls  net_prio          pids        systemd</span><br></pre></td></tr></table></figure>

<p>代表了可操作的各种资源</p>
<p>以cpu资源为例，查看<code>cpu</code>目录，执行<code>ls /sys/fs/cgroup/cpu</code>可以看到如下列表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:$ ls /sys/fs/cgroup/cpu</span><br><span class="line">cgroup.clone_children  cpuacct.usage_all          cpuacct.usage_user  notify_on_release  user.slice</span><br><span class="line">cgroup.procs           cpuacct.usage_percpu       cpu.cfs_period_us   release_agent</span><br><span class="line">cgroup.sane_behavior   cpuacct.usage_percpu_sys   cpu.cfs_quota_us    system.slice</span><br><span class="line">cpuacct.stat           cpuacct.usage_percpu_user  cpu.shares          tasks</span><br><span class="line">cpuacct.usage          cpuacct.usage_sys          cpu.stat</span><br></pre></td></tr></table></figure>

<p>其中<code>tasks</code>文件列出了受限制的进程pid列表，<code>cpu.cfs_period_us</code>和<code>cpu.cfs_quota_us</code>文件搭配使用可以达到限制cpu使用率的目的，打开两个文件分别看到内容如下</p>
<p><code>cpu.cfs_period_us</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">100000</span><br></pre></td></tr></table></figure>

<p><code>cpu.cfs_quota_us</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1</span><br></pre></td></tr></table></figure>

<p>表示100000us时间内不限制分配的cpu时间长度（-1表示不限制，如果将-1换成30000则表示允许分配30000us即30ms的cpu时间）</p>
<h2 id="实践一下"><a href="#实践一下" class="headerlink" title="实践一下"></a>实践一下</h2><p>cgroup是树型结构的，可以在当前树下新建子节点，根目录<code>/sys/fs/cgroup/cpu</code>一般表示整个计算机。所以我们不是直接操作<code>/sys/fs/cgroup/cpu</code>下面的文件，而是在目录树下创建一个名为<code>test</code>的子目录，查看目录可以发现操作系统会在新建的<code>test</code>目录下自动生成了该系统对应的资源限制文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:$ cd /sys/fs/cgroup/cpu</span><br><span class="line">root@ubuntu:/sys/fs/cgroup/cpu$ mkdir test</span><br><span class="line">root@ubuntu:/sys/fs/cgroup/cpu$ cd test</span><br><span class="line">root@ubuntu:/sys/fs/cgroup/cpu$ </span><br><span class="line">root@ubuntu:/sys/fs/cgroup/cpu/test$ ls</span><br><span class="line">cgroup.clone_children  cpuacct.usage         cpuacct.usage_percpu_sys   cpuacct.usage_user  cpu.shares         tasks</span><br><span class="line">cgroup.procs           cpuacct.usage_all     cpuacct.usage_percpu_user  cpu.cfs_period_us   cpu.stat</span><br><span class="line">cpuacct.stat           cpuacct.usage_percpu  cpuacct.usage_sys          cpu.cfs_quota_us    notify_on_release</span><br></pre></td></tr></table></figure>

<p>接下来，先启动两个用于测试的死循环进程，进程号分别为15007和15952</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:/sys/fs/cgroup/cpu/test$ while : ; do : ; done &amp;</span><br><span class="line">[1] 15007</span><br><span class="line">root@ubuntu:/sys/fs/cgroup/cpu/test$ while : ; do : ; done &amp;</span><br><span class="line">[2] 15952</span><br></pre></td></tr></table></figure>

<p>查看此时的cpu使用情况，cpu使用率达到了93.8%</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND</span><br><span class="line">15952 root      20   0   22776   2960   1212 R 50.0  0.1  18:18.90 bash</span><br><span class="line">15007 root      20   0   22776   1684      0 R 43.8  0.1  24:04.92 bash</span><br></pre></td></tr></table></figure>

<p>修改<code>cpu.cfs_quota_us</code>文件和<code>tasks</code>文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:/sys/fs/cgroup/cpu/test$ echo &quot;40000&quot; &gt; cpu.cfs_quota_us</span><br><span class="line">root@ubuntu:/sys/fs/cgroup/cpu/test$ echo -e &quot;15007\n15952&quot; &gt; tasks</span><br></pre></td></tr></table></figure>

<p>查看此时的cpu使用情况，发现cpu使用率成功降下来了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND</span><br><span class="line">15952 root      20   0   22776   2960   1212 R 20.3  0.1  20:04.56 bash</span><br><span class="line">15007 root      20   0   22776   1684      0 R 19.9  0.1  25:50.57 bash</span><br></pre></td></tr></table></figure>

<h3 id="添加限制的进程"><a href="#添加限制的进程" class="headerlink" title="添加限制的进程"></a>添加限制的进程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:/sys/fs/cgroup/cpu/test$ echo -e &quot;1234&quot; &gt; tasks</span><br></pre></td></tr></table></figure>

<p>虽然上面写文件使用的符号是单大于号<code>&gt;</code>，但实际上并不会覆盖原本文件，实际效果是添加一个pid为1234的进程到该cgroup组中</p>
<h3 id="移除进程限制"><a href="#移除进程限制" class="headerlink" title="移除进程限制"></a>移除进程限制</h3><p>在cgroup数中，一个进程必须属于一个cgroup，所以不能从一个cgroup凭空删除一个进程，只能将进程移动到其他cgroup节点，所以删除操作也便成为了将进程移动到cgroup树的根节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:/sys/fs/cgroup/cpu/test$ echo &quot;15007&quot; &gt; ../tasks</span><br></pre></td></tr></table></figure>

<h3 id="删除cgroup组"><a href="#删除cgroup组" class="headerlink" title="删除cgroup组"></a>删除cgroup组</h3><p>删除cgroup文件夹即可，但这里使用<code>rm -rf test</code>是行不通的，需要使用<code>rmdir</code>命令。（删除时需确保cgroup组中没有进程存在）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:/sys/fs/cgroup/cpu$ rmdir test</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://page.uetty.com/2019/11/25/linux-cgroup-cpu/" data-id="ck5qhi06k001sg0uk2hoxyv2u" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-log4j" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/15/log4j/" class="article-date">
  <time datetime="2019-08-15T14:36:07.000Z" itemprop="datePublished">2019-08-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/15/log4j/">log4j xml配置文件个人配置如何不污染GIT远程仓库</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在spring中通常使用xml方式配置log4j。通常开发人员根据自身习惯会在本地开发环境设置令自己舒适的日志打印级别，然而在团队合作编程中，常因配置文件误提交导致污染GIT远程仓库。</p>
<p>针对这个问题，这里分享一个小经验——借助命令行参数在不改变文件的情况下，使配置更加的舒适</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol>
<li><p>首先修改xml配置文件的参数为<code>${}</code>形式，如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;logger name=&quot;com.xxx.dao&quot; level=&quot;$&#123;sys:log4j.level.dao:-WARN&#125;&quot; additivity=&quot;false&quot;&gt;</span><br><span class="line">    &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;</span><br><span class="line">&lt;/logger&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行命令添加参数值设置自己的习惯级别，IDEA为例在<code>VM options</code>后补加一个变量<code>log4j.level.dao</code>的参数设定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Dlog4j.level.dao=debug</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>此时，使用配置了该参数的启动项启动日志级别即为debug级别</p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>实际上，添加VM options参数的方式，不止适用于这里，同样适用于覆盖已有的properties文件、yml文件的配置，只是log4j比较特殊，这里特意写篇博客单独记述。<br>在log4j中，<code>${}</code>的使用方式与其他地方有所不同</p>
<ol>
<li>log4j中的<code>${}</code>并不能识别项目的properties文件的内容</li>
<li>log4j中的<code>${}</code>属性引用格式与其他地方不同，下面具体解释</li>
</ol>
<p>在log4j中，<code>${}</code>参数<code>sys:log4j.level.dao:-WARN</code>中，<code>sys</code>表示使用<code>SystemPropertiesLookup</code>转化参数，<code>:</code>和<code>:-</code>之间表示属性名，<code>:-</code>之后表示默认值。<code>Lookup</code>的类型可在<code>org.apache.logging.log4j.core.lookup.Interpolator#Interpolator(java.util.Map&lt;java.lang.String,java.lang.String&gt;)</code>中看到，有多个不同的lookup。</p>
<p>去官网转了一圈，也有看到lookup使用的相关介绍<a href="https://logging.apache.org/log4j/2.x/manual/lookups.html#SystemPropertiesLookup" target="_blank" rel="noopener">链接</a>，但说实话，没看过源码的话可能不是很好理解，所以最好还是稍微阅读一下源码</p>
<p>题外话，看了log4j部分源码，实际上log4j获取默认配置文件地址的源码位于<code>org.apache.logging.log4j.core.config.ConfigurationFactory.Factory#getConfiguration(boolean, java.lang.String)</code></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://page.uetty.com/2019/08/15/log4j/" data-id="ck5qhi06i001qg0uk62ih4sof" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/log4j/">log4j</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-common-excel" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/31/common-excel/" class="article-date">
  <time datetime="2019-07-31T14:36:06.000Z" itemprop="datePublished">2019-07-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/31/common-excel/">阿里Easy Excel自定义样式注解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>现在是第一版common-excel，基于<code>alibaba/easyexcel</code>依赖进行样式扩展封装而来的，增加了一些样式注解</p>
<h2 id="可以解决什么问题"><a href="#可以解决什么问题" class="headerlink" title="可以解决什么问题"></a>可以解决什么问题</h2><ol>
<li>注解式样式</li>
<li>代码方式自定义样式</li>
<li>冻结行列样式</li>
<li>合并单元格样式</li>
<li>设置内容下拉框</li>
<li>背景颜色</li>
<li>字体设置</li>
<li>列宽度设置</li>
<li>边框样式</li>
<li>居中方式</li>
<li>是否换行</li>
</ol>
<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><img src="../static/MB19073101-1.png" alt="img - 1"> </p>
<p><img src="../static/MB19073101-2.png" alt="img - 2"> </p>
<h2 id="DEMO"><a href="#DEMO" class="headerlink" title="DEMO"></a>DEMO</h2><p>model代码示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@CellFreeze(freezeRow = 2, freezeCol = 2)</span><br><span class="line">// 宽度默认值</span><br><span class="line">@ColumnWidth(width = 40)</span><br><span class="line">// 同时作用于表标题和内容的样式默认值</span><br><span class="line">@CellStyle(fontStyle = @FontStyle(color = IndexedColors.LIGHT_BLUE, size = 14))</span><br><span class="line">public class MyModel1 extends BaseRowModel &#123;</span><br><span class="line"></span><br><span class="line">    // easyexcel 解析注解</span><br><span class="line">    @ExcelProperty(value=&#123;&quot;pri&quot;, &quot;pr1&quot;&#125;, index = 0)</span><br><span class="line">    private String pr1;</span><br><span class="line"></span><br><span class="line">    @ExcelProperty(value=&#123;&quot;pri&quot;, &quot;pr2&quot;&#125;, index = 1)</span><br><span class="line">    private String pr2;</span><br><span class="line"></span><br><span class="line">    @ExcelProperty(value = &#123;&quot;propValue1&quot;&#125;, index = 2)</span><br><span class="line">    // 数组方式指定的下拉框约束</span><br><span class="line">    @ExplicitConstraint(source = &#123;&quot;aaa1&quot;, &quot;aaa2&quot;, &quot;aaa3&quot;&#125;)</span><br><span class="line">    @ColumnWidth(width = 100)</span><br><span class="line">    private String propValue1;</span><br><span class="line"></span><br><span class="line">    @ExcelProperty(value = &#123;&quot;propValue2&quot;&#125;, index = 3)</span><br><span class="line">    @ExplicitConstraint(enumSource = MyConstraintEnum.class)</span><br><span class="line">    private String propValue2;</span><br><span class="line"></span><br><span class="line">    @ExcelProperty(value = &#123;&quot;score&quot;&#125;, index = 4)</span><br><span class="line">    @ColumnWidth(width = 50)</span><br><span class="line">    private Integer score;</span><br><span class="line"></span><br><span class="line">    @ExcelProperty(value = &#123;&quot;date&quot;&#125;, index = 5, format = &quot;yyyy-MM-dd HH:mm:ss&quot;)</span><br><span class="line">    private Date date;</span><br><span class="line"></span><br><span class="line">    public String getPr1() &#123;</span><br><span class="line">        return pr1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPr1(String pr1) &#123;</span><br><span class="line">        this.pr1 = pr1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getPr2() &#123;</span><br><span class="line">        return pr2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPr2(String pr2) &#123;</span><br><span class="line">        this.pr2 = pr2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getPropValue1() &#123;</span><br><span class="line">        return propValue1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPropValue1(String propValue1) &#123;</span><br><span class="line">        this.propValue1 = propValue1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getPropValue2() &#123;</span><br><span class="line">        return propValue2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPropValue2(String propValue2) &#123;</span><br><span class="line">        this.propValue2 = propValue2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getScore() &#123;</span><br><span class="line">        return score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setScore(Integer score) &#123;</span><br><span class="line">        this.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Date getDate() &#123;</span><br><span class="line">        return date;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setDate(Date date) &#123;</span><br><span class="line">        this.date = date;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>详细代码戳下方链接<br><a href="https://github.com/Uetty/common-excel" target="_blank" rel="noopener">仓库主页</a></p>
<p><a href="https://github.com/Uetty/common-excel/blob/master/src/main/java/com/uetty/common/excel/demo/withhead/TestWithHeadModel.java" target="_blank" rel="noopener">有标题头demo</a></p>
<p><a href="https://github.com/Uetty/common-excel/blob/master/src/main/java/com/uetty/common/excel/demo/headless/TestHeadlessModel1.java" target="_blank" rel="noopener">无标题头demo1</a></p>
<p><a href="https://github.com/Uetty/common-excel/blob/master/src/main/java/com/uetty/common/excel/demo/headless/TestHeadlessModel2.java" target="_blank" rel="noopener">无标题头demo2</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://page.uetty.com/2019/07/31/common-excel/" data-id="ck5qhi06h001ng0ukbiu3xjs0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/open-source/">open source</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-compare-list-vertor-cowlist" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/29/compare-list-vertor-cowlist/" class="article-date">
  <time datetime="2019-07-29T11:33:16.000Z" itemprop="datePublished">2019-07-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/29/compare-list-vertor-cowlist/">ArrayList、Vector、CopyOnWriteArrayList对比</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>ArrayList、Vector、CopyOnWriteArrayList均是实现了List接口的容器，他们之间究竟有何区别？为何JDK要同时提供这三种List？本文针对这个问题，进行深入的探究。</p>
<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><h3 id="1-研究一个类源码，首先了解它有哪些成员变量"><a href="#1-研究一个类源码，首先了解它有哪些成员变量" class="headerlink" title="1. 研究一个类源码，首先了解它有哪些成员变量"></a>1. 研究一个类源码，首先了解它有哪些成员变量</h3><p>查看ArrayList源码，可以很清除的看到，ArrayList最主要的成员变量就两个，变量的作用很明显，存储对象数组和记录数组内存储的变量个数，ArrayList内元素是以Array方式存储的，所以叫做ArrayList</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* The array buffer into which the elements of the ArrayList are stored.</span><br><span class="line">* The capacity of the ArrayList is the length of this array buffer. Any</span><br><span class="line">* empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><br><span class="line">* will be expanded to DEFAULT_CAPACITY when the first element is added.</span><br><span class="line">*/</span><br><span class="line">transient Object[] elementData; // non-private to simplify nested class access</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* The size of the ArrayList (the number of elements it contains).</span><br><span class="line">*</span><br><span class="line">* @serial</span><br><span class="line">*/</span><br><span class="line">private int size;</span><br></pre></td></tr></table></figure>

<h3 id="2-针对特征功能的探究"><a href="#2-针对特征功能的探究" class="headerlink" title="2. 针对特征功能的探究"></a>2. 针对特征功能的探究</h3><p>ArrayList之所以是一个List，而不是Array，就在于ArrayList长度可以扩展，这里探究它在add元素时是如何进行扩容的。</p>
<p>查看add代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* Appends the specified element to the end of this list.</span><br><span class="line">*</span><br><span class="line">* @param e element to be appended to this list</span><br><span class="line">* @return &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;@link Collection#add&#125;)</span><br><span class="line">*/</span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    ensureCapacityInternal(size + 1);  // Increments modCount!!</span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出ArrayList的扩容是在ensureCapacityInternal方法中完成的，按着ensureCapacityInternal方法顺藤摸瓜可以找到grow方法这里才是真正的扩容代码，可以看出ArrayList扩容是直接用新的更长的数组替换掉旧的elementData数组，扩容后新容量是扩容前的容量的1.5倍，并与实际需求容量取最大值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* Increases the capacity to ensure that it can hold at least the</span><br><span class="line">* number of elements specified by the minimum capacity argument.</span><br><span class="line">*</span><br><span class="line">* @param minCapacity the desired minimum capacity</span><br><span class="line">*/</span><br><span class="line">private void grow(int minCapacity) &#123;</span><br><span class="line">    // overflow-conscious code</span><br><span class="line">    int oldCapacity = elementData.length;</span><br><span class="line">    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class="line">    if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">    newCapacity = minCapacity;</span><br><span class="line">    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">    newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    // minCapacity is usually close to size, so this is a win:</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><p>Vector类相比较ArrayList类，在成员变量上多了一个<code>protected int capacityIncrement</code>变量，主要用于扩容时的容量增长的计算，也就是说，Vector容量增长值的算法与ArrayList是有所不同的。</p>
<p>将关注点置于Vector与ArrayList类的不同点上，阅读源码可发现Vector类在<code>get</code>、<code>add</code>、<code>set</code>、<code>addAll</code>、<code>forEach</code>、<code>toArray</code>等方法上，均加了<code>synchronized</code>关键字，这里可以看出，Vector类与ArrayList相比增加了线程安全方面的考虑。</p>
<h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><p>成员变量上，主要增加了一个ReentrantLock变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/** The lock protecting all mutators */</span><br><span class="line">final transient ReentrantLock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">/** The array, accessed only via getArray/setArray. */</span><br><span class="line">private transient volatile Object[] array;</span><br></pre></td></tr></table></figure>

<p>了解<code>ReentrantLock</code>类的都知道，这是一个可重入锁，也就是说CopyOnWriteArrayList和Vector一样都有线程安全方面的考虑。那CopyOnWriteArrayList和Vector的区别是什么呢？</p>
<p>阅读CopyOnWriteArrayList源码发现，CopyOnWriteArrayList类在<code>get</code>、<code>forEach</code>、<code>toArray</code>等读的方法上，并没有加锁。在<code>add</code>、<code>set</code>、<code>addAll</code>等写的方法上除了使用了ReentrantLock锁之外，还增加了Array Copy的操作，使用Copy出的新的Array替换了就的Array，也正是因为这个操作，使得CopyOnWriteArrayList类在写的操作上不需要加锁。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ArrayList与 CopyOnWriteArrayList和Vector的区别在于，CopyOnWriteArrayList和Vector是线程安全的，ArrayList不是线程安全的。CopyOnWriteArrayList和Vector的区别在于，CopyOnWriteArrayList读时不加锁，Vector读时加锁，CopyOnWriteArrayList写时进行了Array的拷贝，而Vector不进行拷贝。从性能上看，不加锁的ArrayList读写速度肯定都是最快的，而Vector写的速度比CopyOnWriteArrayList快，CopyOnWriteArrayList读的速度比Vector块。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://page.uetty.com/2019/07/29/compare-list-vertor-cowlist/" data-id="ck5qhi06f001lg0ukbj0u0l3s" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java-garbage-collector" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/17/java-garbage-collector/" class="article-date">
  <time datetime="2019-07-16T20:36:17.000Z" itemprop="datePublished">2019-07-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/17/java-garbage-collector/">JAVA垃圾收集器科普</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Serial收集器（新生代）"><a href="#Serial收集器（新生代）" class="headerlink" title="Serial收集器（新生代）"></a>Serial收集器（新生代）</h2><p>垃圾收集时，必须暂停其他所有工作线程（Stop The World)，采用的是复制回收算法，单线程收集</p>
<h2 id="Serial-Old搜集器（老年代）"><a href="#Serial-Old搜集器（老年代）" class="headerlink" title="Serial Old搜集器（老年代）"></a>Serial Old搜集器（老年代）</h2><p>Serial收集器的老年代版本</p>
<h2 id="ParNew收集器（新生代）"><a href="#ParNew收集器（新生代）" class="headerlink" title="ParNew收集器（新生代）"></a>ParNew收集器（新生代）</h2><p>serial收集器的多线程版本，没有太多的提升</p>
<h2 id="Parallel-Scavenge收集器（新生代）"><a href="#Parallel-Scavenge收集器（新生代）" class="headerlink" title="Parallel Scavenge收集器（新生代）"></a>Parallel Scavenge收集器（新生代）</h2><p>复制回收算法，并发多线程收集器，特点是与其他关注缩短垃圾收集时停顿时间的收集器的关注点不同，目标是达到可控的吞吐量（=运行用户代码时间/(运行用户代码时间 + 垃圾收集时间)），参数的两种设置方式：</p>
<ol>
<li>使用<code>-XX:MaxGCPauseMillis</code>参数，直接制定大于0的毫秒数，收集器将尽可能地保证手机时间不超过设定值。但如果值设定过小，可能导致频繁垃圾回收。</li>
<li>使用<code>-XX:GCTimeRatio</code>参数，设定值大于0小于100整数，如果设定49，则GC时间占总时间的2%（1 / (1 + 49)），默认值为99.</li>
</ol>
<p>另外还有一个常用参数<code>-XX:+UseAdaptiveSizePolicy</code>，是开关参数，设定后无需手工指定新生代、Eden区、Survivor区的比例、晋升老年代年龄（<code>-XX:PretenureSizeThreshold</code>），虚拟机将自动调整这些参数以提供最适合的停顿时间和吞吐量。</p>
<h2 id="Parallel-Old收集器（老年代）"><a href="#Parallel-Old收集器（老年代）" class="headerlink" title="Parallel Old收集器（老年代）"></a>Parallel Old收集器（老年代）</h2><p>Parallel Scavenge收集器的老年代版本</p>
<h2 id="CMS收集器（老年代）"><a href="#CMS收集器（老年代）" class="headerlink" title="CMS收集器（老年代）"></a>CMS收集器（老年代）</h2><p>CMS(Concurrent Mark Sweep)收集器，是有较大提升的一个版本，采用的是标记清清理算法，同时是地一个真正意义上的并发收集器，以获取最短回收停顿时间为目标。</p>
<p>垃圾收集过程分为4个步骤：</p>
<ol>
<li>初始标记</li>
<li>并发标记</li>
<li>重新标记</li>
<li>并发清除</li>
</ol>
<p>初始标记、重新标记两个步骤仍旧需要”Stop The World”，但这两个阶段都是耗时比较短的阶段。初始标记，只是标记GC Roots能够直接到达的对象，速度很快；并发标记阶段为进行GC Tracing的过程；重新标记阶段为了修正并发标记期间用户程序继续运作而导致的标记变动部分记录，比初始标记阶段时间稍长，但远低于并发标记阶段。</p>
<p>不足点：</p>
<ol>
<li>并发程序的通病，对CPU资源敏感，线程占用资源不可避免的导致程序变慢（吞吐量降低），及线程切换的消耗，默认启动的线程数量（(CPU数量 + 3)  / 4）。</li>
<li>标记清楚回收算法的常见问题，导致内存空间的碎片，碎片过多大对象分配会带来麻烦，无法找到足够大空间时，不得不提前触发Full GC。参数<code>-XX:+UseCMSCompactAtFullCollection</code>用于在CMS收集器顶不住要FullGC时开启碎片压缩整合（默认即是开启的），但整合过程无法并发。参数<code>-XX:CMSFullGCsBeforeCompaction</code>设置多少次不压缩后执行一次压缩整合（默认值0）</li>
<li>收集器运行时需要为浮动垃圾（并发搜集阶段用户线程仍在运行而产生的垃圾）预留足够内存空间，浮动垃圾在下一次GC时清理掉，因此不能像其他收集器一样等到几乎被填满时再进行收集。JDK1.5中默认68%空间时收集，JDK1.6中为92%，使用<code>-XX:CMSInitiatingOccupancyFraction</code>参数设置百分比。</li>
<li>concurrent mark时预留的内存无法满足程序需要，会导致<code>Concurrent Mode Failure</code>失败，这是虚拟机启用后备预案，临时使用Serial Old收集器重新进行老年代的垃圾收集。</li>
<li>CMS作为老年代收集器，无法与Parallel Scavenge收集器配合使用，只能与Serial收集器或ParNew收集器配合使用</li>
</ol>
<h2 id="G1收集器（不再物理性分代）"><a href="#G1收集器（不再物理性分代）" class="headerlink" title="G1收集器（不再物理性分代）"></a>G1收集器（不再物理性分代）</h2><p>最新的收集器，目标替换CMS收集器，仍需要更多的检验。从2004年论文发布起，近10年时间才推出的G1收集器的商用版本，采用化整为零的思路，将Java堆分成多个Region进行管理。但由于对象的引用实现上并没有看起来这么简单，与新生代老年代类似，每个Region区均为此留出了Remembered Set来避免全堆扫描。</p>
<p>G1收集器运行大致分为4个步骤：</p>
<ol>
<li>初始标记</li>
<li>并发标记</li>
<li>最终标记</li>
<li>筛选回收</li>
</ol>
<p>4个阶段与CMS收集器相似，在最终标记阶段，将并发阶段写在线程Remembered Set Logs里的标记变动记录合并到Remembered Set中。筛选回收阶段对各个Region回收价值和成本先进行排序，根据用户期望GC停顿时间来制定回收计划。</p>
<p>G1收集器特点：</p>
<ol>
<li>并行与并发，多CPU环境缩短Stop-The-World</li>
<li>将整个Java堆分成多个大小相等的独立的Region，分代概念仍在G1收集器保留，但新生代和老年代不再是物理隔离的了，它们都是一部分Region的集合</li>
<li>可以不需要其他收集器配合就能独立管理整个GC堆，并能够采用不同方式处理新创建的和旧的对象</li>
<li>整体上采用”标记-整理”算法，局部（两个Region之间）基于”复制回收”算法</li>
<li>一大特色优势点，可预测的停顿。与CMS收集器一样关注降低停顿时间之外，还建立了可预测的停顿时间模型，能让使用者明确指定控制在长度为M的毫秒时间片段内，消耗在垃圾收集上的时间不超过N毫秒。</li>
</ol>
<p>可预测的停顿，建立在有计划地避免在整个Java堆中进行全区域垃圾收集，G1跟踪各个Region里的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先级列表，每次根据允许的收集时间优先回收高价值Region （这也是Garbage-First名称的由来）。</p>
<p>Sun给出测试结果显示，G1收集器对停顿时间的控制比CMS要更加地稳定可靠得多。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://page.uetty.com/2019/07/17/java-garbage-collector/" data-id="ck5qhi06d001ig0ukt56bdsex" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java-linux-timezone" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/10/java-linux-timezone/" class="article-date">
  <time datetime="2019-07-10T13:11:18.000Z" itemprop="datePublished">2019-07-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/10/java-linux-timezone/">Java及Ubuntu操作系统时区错误</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>程序部署时出现Java时间不正确，Java里打印<code>new Date()</code>后发现输出的时区不是CST，是时区不正确导致的问题。针对该问题进行修复，修改时区设置，配置如下:</p>
<ol>
<li><p>修改<code>/etc/localtime</code>软链接指向为<code>/usr/share/zoneinfo/Asia/Shanghai</code></p>
<blockquote>
<p>ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</p>
</blockquote>
</li>
</ol>
<p>此时出现了一个很有意思的现象：shell执行打印时间的命令<code>date</code>，发现输出时区为CST，但Java打印 <code>new Date()</code>输出，时区仍旧不是CST</p>
<ol start="2">
<li><p>修改<code>/etc/timezone</code>文件，将文件内唯一的一行<code>America/New_York</code>改为<code>Asia/Shanghai</code>，Java打印<code>new Date()</code>，输出时区为CST，修改成功</p>
</li>
<li><p>（相似的题外问题）如果需要修改系统字符集，可以修改<code>/etc/default/locale</code>（基于Ubuntu）文件设置为如下所示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LANG=&quot;zh_CN.UTF-8&quot;</span><br><span class="line">LANGUAGE=&quot;zh_CN:zh&quot;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>可以通过<code>locale -a</code>查看是否安装<code>zh_CN.UTF-8</code>字体，如未安装，通过<code>locale-gen zh_CN.UTF-8</code>命令安装</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://page.uetty.com/2019/07/10/java-linux-timezone/" data-id="ck5qhi06c001gg0ukcqeqdok0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/IDE/">IDE</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MyBatis/">MyBatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RabbitMQ/">RabbitMQ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/api/">api</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/">css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dubbo/">dubbo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/encoding/">encoding</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/log4j/">log4j</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/maven/">maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/open-source/">open source</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/">spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vulnerability/">vulnerability</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/图论/">图论</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/IDE/" style="font-size: 10px;">IDE</a> <a href="/tags/MyBatis/" style="font-size: 10px;">MyBatis</a> <a href="/tags/RabbitMQ/" style="font-size: 10px;">RabbitMQ</a> <a href="/tags/api/" style="font-size: 12px;">api</a> <a href="/tags/css/" style="font-size: 10px;">css</a> <a href="/tags/docker/" style="font-size: 10px;">docker</a> <a href="/tags/dubbo/" style="font-size: 10px;">dubbo</a> <a href="/tags/encoding/" style="font-size: 10px;">encoding</a> <a href="/tags/java/" style="font-size: 20px;">java</a> <a href="/tags/linux/" style="font-size: 18px;">linux</a> <a href="/tags/log4j/" style="font-size: 10px;">log4j</a> <a href="/tags/maven/" style="font-size: 10px;">maven</a> <a href="/tags/mysql/" style="font-size: 14px;">mysql</a> <a href="/tags/open-source/" style="font-size: 10px;">open source</a> <a href="/tags/redis/" style="font-size: 10px;">redis</a> <a href="/tags/spring/" style="font-size: 16px;">spring</a> <a href="/tags/vulnerability/" style="font-size: 10px;">vulnerability</a> <a href="/tags/图论/" style="font-size: 10px;">图论</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">2020-02</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">2020-01</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">2019-12</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">2019-11</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">2019-08</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">2019-07</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">2019-06</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">2019-05</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">2019-04</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">2019-03</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">2019-02</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">2018-12</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">2018-11</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">2018-10</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">2018-09</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">2018-08</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">2018-06</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">2018-03</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">2018-02</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">2017-12</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">2017-09</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">2017-08</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">2017-07</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">2017-05</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">2017-03</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/02/23/character-set-encoding/">从二分图开始到最大匹配</a>
          </li>
        
          <li>
            <a href="/2020/02/13/character-set-encoding/">理解字符集编码及Java内存编码运行机制</a>
          </li>
        
          <li>
            <a href="/2020/01/08/gitlab-api/">Gitlab Api</a>
          </li>
        
          <li>
            <a href="/2019/12/11/source-bitcount/">JDK中Integer.bitCount解析</a>
          </li>
        
          <li>
            <a href="/2019/11/25/linux-cgroup-cpu/">Linux限制进程CPU上限</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Vince<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>