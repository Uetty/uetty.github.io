<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>RabbitMQ快速入门手册 | Vince Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="1. 安装使用docker方式，拉取镜像uetty/rabbitmq 具体Dockerfile的命令 -&amp;gt; Dockerfile 额外的TIP: 由于Linux机器上会有最大打开文件个数限制，Rabbitmq又依赖文件操作，所以应将Linux的所有用户打开文件限制调高到64000，Rabbitmq程序所属的用户的打开文件限制调高到64000，这一块见官网（文件限制） 2. 虚拟主机Rabbi">
<meta name="keywords" content="rabbitmq, 教程，安装">
<meta property="og:type" content="article">
<meta property="og:title" content="RabbitMQ快速入门手册">
<meta property="og:url" content="https://page.uetty.com/2019/04/22/rabbitmq/index.html">
<meta property="og:site_name" content="Vince Blog">
<meta property="og:description" content="1. 安装使用docker方式，拉取镜像uetty/rabbitmq 具体Dockerfile的命令 -&amp;gt; Dockerfile 额外的TIP: 由于Linux机器上会有最大打开文件个数限制，Rabbitmq又依赖文件操作，所以应将Linux的所有用户打开文件限制调高到64000，Rabbitmq程序所属的用户的打开文件限制调高到64000，这一块见官网（文件限制） 2. 虚拟主机Rabbi">
<meta property="og:locale" content="zh_CN">
<meta property="og:updated_time" content="2020-01-23T08:21:31.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="RabbitMQ快速入门手册">
<meta name="twitter:description" content="1. 安装使用docker方式，拉取镜像uetty/rabbitmq 具体Dockerfile的命令 -&amp;gt; Dockerfile 额外的TIP: 由于Linux机器上会有最大打开文件个数限制，Rabbitmq又依赖文件操作，所以应将Linux的所有用户打开文件限制调高到64000，Rabbitmq程序所属的用户的打开文件限制调高到64000，这一块见官网（文件限制） 2. 虚拟主机Rabbi">
  
    <link rel="alternate" href="/atom.xml" title="Vince Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Vince Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//www.baidu.com/s" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q1" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="q6" value="page.uetty.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-rabbitmq" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/22/rabbitmq/" class="article-date">
  <time datetime="2019-04-22T09:01:43.000Z" itemprop="datePublished">2019-04-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      RabbitMQ快速入门手册
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h2><p>使用docker方式，拉取镜像uetty/rabbitmq</p>
<p>具体Dockerfile的命令 -&gt; <a href="https://github.com/Uetty/dockerfile/blob/master/docker-rabbitmq/Dockerfile" target="_blank" rel="noopener">Dockerfile</a></p>
<p>额外的TIP: 由于Linux机器上会有最大打开文件个数限制，Rabbitmq又依赖文件操作，所以应将Linux的所有用户打开文件限制调高到64000，Rabbitmq程序所属的用户的打开文件限制调高到64000，这一块见官网（<a href="https://www.rabbitmq.com/install-debian.html#kernel-resource-limits" target="_blank" rel="noopener">文件限制</a>）</p>
<h2 id="2-虚拟主机"><a href="#2-虚拟主机" class="headerlink" title="2. 虚拟主机"></a>2. 虚拟主机</h2><p>Rabbitmq是多租户系统，存在虚拟主机（把它想象成为数据库）的概念，用户对它的连接、队列、绑定、路由等操作是基于虚拟主机上的。通过<code>rabbitmqctl add_vhost vhostname</code>命令来增加虚拟主机，<code>rabbitmqctl delete_vhost vhostname</code>命令来删除虚拟主机，<code>rabbitmqctl list_vhosts [name tracing]</code>命令来显示虚拟主机列表。</p>
<p>设置虚拟主机并发客户端总数：<code>rabbitmqctl set_vhost_limits -p test &#39;{&quot;max-connections&quot;: 256}&#39;</code></p>
<p>设置虚拟主机最大队列数：<code>rabbitmqctl set_vhost_limits -p test &#39;{&quot;max-queues&quot;: 1024}&#39;</code></p>
<p>显示虚拟主机参数：<code>rabbitmqctl list_vhost_limits -p test</code></p>
<h2 id="3-启动与用户操作及权限"><a href="#3-启动与用户操作及权限" class="headerlink" title="3. 启动与用户操作及权限"></a>3. 启动与用户操作及权限</h2><p>启动命令：<code>service rabbitmq-server start</code>  </p>
<p>Rabbit提供了用户名密码的方式认证和X509证书的方式认证，，这里只记用户名密码的方式 </p>
<p>初始用户：刚创建的实例，有默认的用户guest密码guest，但只能在本机登陆（不鼓励将其配置成能远程登陆，其他用户默认是可以远程访问的） </p>
<h3 id="用户设置（官网地址-）"><a href="#用户设置（官网地址-）" class="headerlink" title="用户设置（官网地址 ）"></a>用户设置（<a href="https://www.rabbitmq.com/rabbitmqctl.8.html#User_Management" target="_blank" rel="noopener">官网地址</a> ）</h3><p>添加用户：<code>rabbitmqctl add_user janeway changeit</code> </p>
<p>删除用户：<code>rabbitmqctl delete_user janeway</code> </p>
<p>变更密码：<code>rabbitmqctl change_password janeway newpass</code> </p>
<p>验证用户名密码：<code>rabbitmqctl authenticate_user janeway verifyit</code> </p>
<p>显示用户列表：<code>rabbitmqctl list_users</code> </p>
<h3 id="用户权限"><a href="#用户权限" class="headerlink" title="用户权限"></a>用户权限</h3><p>设置用户TAG：<code>rabbitmqctl set_user_tags janeway administrator</code> </p>
<p>删除用户TAG：<code>rabbitmqctl set_user_tags janeway</code> </p>
<p>TIP: 用户TAG与全局权限绑定（包括登陆可视化管理界面的权限等），具体见官网（<a href="https://www.rabbitmq.com/management.html#permissions" target="_blank" rel="noopener">TAG权限表</a>）</p>
<table>
<thead>
<tr>
<th align="left">Tag</th>
<th align="left">Capabilities</th>
</tr>
</thead>
<tbody><tr>
<td align="left">(None)</td>
<td align="left">No access to the management plugin</td>
</tr>
<tr>
<td align="left">management</td>
<td align="left">Anything the user could do via messaging protocols plus:List virtual hosts to which they can log in via AMQPView all queues, exchanges and bindings in “their” virtual hostsView and close their own channels and connectionsView “global” statistics covering all their virtual hosts, including activity by other users within them</td>
</tr>
<tr>
<td align="left">policymaker</td>
<td align="left">Everything “management” can plus:View, create and delete policies and parameters for virtual hosts to which they can log in via AMQP</td>
</tr>
<tr>
<td align="left">monitoring</td>
<td align="left">Everything “management” can plus:List all virtual hosts, including ones they could not access using messaging protocolsView other users’s connections and channelsView node-level data such as memory use and clusteringView truly global statistics for all virtual hosts</td>
</tr>
<tr>
<td align="left">administrator</td>
<td align="left">Everything “policymaker” and “monitoring” can plus:Create and delete virtual hostsView, create and delete usersView, create and delete permissionsClose other users’s connections</td>
</tr>
</tbody></table>
<p>设置用户在虚拟主机上的权限：<code>rabbitmqctl set_permissions -p vhostname username &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</code> 后面三个参数分别表示配置权限、写权限、读权限，引号内的内容用正则表达式匹配队列键名（不指定[–vhost/-p]参数，默认主机为’/‘ ，下同） </p>
<p>清除用户在虚拟主机上的权限：<code>rabbitmqctl clear_permissions -p vhostname username</code>  </p>
<p>显示某个用户在虚拟主机上的权限：<code>rabbitmqctl list_user_permissions uetty</code>  </p>
<p>显示某个虚拟主机上的用户权限：<code>rabbitmqctl list_permissions -p vhostname</code></p>
<h2 id="4-端口介绍"><a href="#4-端口介绍" class="headerlink" title="4. 端口介绍"></a>4. 端口介绍</h2><ul>
<li>4369: <a href="http://erlang.org/doc/man/epmd.html" target="_blank" rel="noopener">epmd</a>, a peer discovery service used by RabbitMQ nodes and CLI tools</li>
<li>5672, 5671: used by AMQP 0-9-1 and 1.0 clients without and with TLS</li>
<li>25672: used for inter-node and CLI tools communication (Erlang distribution server port) and is allocated from a dynamic range (limited to a single port by default, computed as AMQP port + 20000). Unless external connections on these ports are really necessary (e.g. the cluster uses <a href="https://www.rabbitmq.com/federation.html" target="_blank" rel="noopener">federation</a> or CLI tools are used on machines outside the subnet), these ports should not be publicly exposed. See <a href="https://www.rabbitmq.com/networking.html" target="_blank" rel="noopener">networking guide</a> for details.</li>
<li>35672-35682: used by CLI tools (Erlang distribution client ports) for communication with nodes and is allocated from a dynamic range (computed as server distribution port + 10000 through server distribution port + 10010). See <a href="https://www.rabbitmq.com/networking.html" target="_blank" rel="noopener">networking guide</a> for details.</li>
<li>15672: <a href="https://www.rabbitmq.com/management.html" target="_blank" rel="noopener">HTTP API</a> clients, <a href="https://www.rabbitmq.com/management.html" target="_blank" rel="noopener">management UI</a> and <a href="https://www.rabbitmq.com/management-cli.html" target="_blank" rel="noopener">rabbitmqadmin</a> (only if the <a href="https://www.rabbitmq.com/management.html" target="_blank" rel="noopener">management plugin</a> is enabled)</li>
<li>61613, 61614: <a href="https://stomp.github.io/stomp-specification-1.2.html" target="_blank" rel="noopener">STOMP clients</a> without and with TLS (only if the <a href="https://www.rabbitmq.com/stomp.html" target="_blank" rel="noopener">STOMP plugin</a> is enabled)</li>
<li>1883, 8883: (<a href="http://mqtt.org/" target="_blank" rel="noopener">MQTT clients</a> without and with TLS, if the <a href="https://www.rabbitmq.com/mqtt.html" target="_blank" rel="noopener">MQTT plugin</a> is enabled</li>
<li>15674: STOMP-over-WebSockets clients (only if the <a href="https://www.rabbitmq.com/web-stomp.html" target="_blank" rel="noopener">Web STOMP plugin</a> is enabled)</li>
<li>15675: MQTT-over-WebSockets clients (only if the <a href="https://www.rabbitmq.com/web-mqtt.html" target="_blank" rel="noopener">Web MQTT plugin</a> is enabled)</li>
</ul>
<p>5671端口：AMQP协议使用，且TLS加密</p>
<p>5672端口：AMQP协议使用，且不加密</p>
<p>15672端口：HTTP协议使用，或者开启可视化管理页面后，页面地址所在端口</p>
<p>61613端口：STOMP协议使用，且不加密</p>
<p>61614端口：STOMP协议使用，且TLS加密</p>
<p>1883端口：MQTT协议使用，且不加密</p>
<p>8883端口：MQTT协议使用，且TLS加密</p>
<p>15674端口：Websocket协议上的STOMP协议使用</p>
<p>15675端口：Websocket协议上的MQTT协议使用</p>
<p>TIP:  较常用的是5672端口（一般选择AMQP协议，有加密需求的化是5671端口）和15672端口</p>
<h2 id="5-交换机、队列与消息的路由"><a href="#5-交换机、队列与消息的路由" class="headerlink" title="5. 交换机、队列与消息的路由"></a>5. 交换机、队列与消息的路由</h2><p>在Rabbitmq中，生产者是将消息推送到交换机里，交换机负责将消息路由到队列中，消费者再从队列中消费消息。这里涉及到了两个概念，<code>交换机</code>和<code>队列</code>，在此基础上引申出了三个操作：<code>交换机的声明</code>、<code>队列的声明</code>、<code>交换机和队列绑定的声明</code>，这三个操作的完成是基于<code>交换机名</code>、<code>队列名</code>、<code>路由键</code>这三个属性的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1) 通过channel.exchangeDeclare(&quot;exchangeName&quot;, BuiltinExchangeType.类型);声明交换机</span><br><span class="line">2) 通过String queueName = channel.queueDeclare().getQueue();声明队列，并返回自动生成的队列的名称</span><br><span class="line">   也可以通过channel.queueDeclare(queueName, durable, exclusive, autoDelete, arguments);声明命名的队列</span><br><span class="line">   第二种声明方式的参数解释：durable为是否持久化到磁盘，它将使服务器重启后数据仍然存在；exclusive为是否排他队列，具有基于连接的排他性；autoDelete是否自动删除，在没有订阅者的情况下是否自动删除</span><br><span class="line">3) 通过channel.queueBind(queueName, &quot;exchangeName&quot;, &quot;routingKey&quot;);绑定队列和交换机</span><br></pre></td></tr></table></figure>

<p>TIP:  队列本身还包含了许多属性，例如：名称、交换代理重启后是否仍保存、自动删除、队列长度等参数，在声明队列的时候可以给定。</p>
<p>交换机种类主要有四种，以下介绍这几种交换机：</p>
<ol>
<li>直连交换机(direct)</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在直连交换机的三个声明操作中，交换机名、队列名都是不能为空字符串，路由键可以为空字符串但已被使用。发送到直连交换机的消息直接根据路由键进行完全匹配，将消息路由到所有以该路由键与该交换机绑定的队列中。</span><br><span class="line"></span><br><span class="line">1) 生产者通过channel.basicPublish(&quot;exchangeName&quot;, routingKey, null, message.getBytes(&quot;UTF-8&quot;));提交数据到Rabbitmq</span><br><span class="line"></span><br><span class="line">2) 消费者通过channel.basicConsume(queueName, true, (consumerTag, delivery) -&gt; &#123;&#125;, consumerTag -&gt; &#123; &#125;);从Rabbitmq消费消息</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>扇形交换机(fanout)</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">该交换机的设计思想是一个消息广播，在扇形交换机的三个声明操作中，路由键名可以为空字符串（事实上它会被忽略）。发送到扇形交换机的消息，会被路由到所有绑定在该交换机上的队列中（与直连交换机不同的是不再根据路由键进行筛选）。</span><br><span class="line"></span><br><span class="line">1) 生产者通过channel.basicPublish(&quot;exchangeName&quot;, &quot;&quot;, null, message.getBytes(&quot;UTF-8&quot;));提交数据到Rabbitmq</span><br><span class="line"></span><br><span class="line">2) 消费者通过channel.basicConsume(queueName, true, (consumerTag, delivery) -&gt; &#123;&#125;, consumerTag -&gt; &#123; &#125;);从Rabbitmq消费消息</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>主题交换机(topic)</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在主题交换机的三个声明中，路由键的命名是受限制的，必须由点号分割的多个单词或星号或井号组成，*用于匹配一个单词，井号用于匹配零到多个单词，发送到主题交换机的消息，会根据路由键匹配来路由到队列中。</span><br><span class="line"></span><br><span class="line">1) 生产者通过channel.basicPublish(EXCHANGE_NAME, routingKey, null, message.getBytes(&quot;UTF-8&quot;));发送数据到Rabbitmq</span><br><span class="line"></span><br><span class="line">2) 消费者通过channel.basicConsume(queueName, true, (consumerTag, delivery) -&gt; &#123;&#125;, consumerTag -&gt; &#123; &#125;);从Rabbitmq消费消息</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>首部交换机(match 和 headers)</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">在首部交换机中，路由键名可以是空字符串（事实上它会被忽略），它的路由规则转而由首部属性决定，其中最重要的一个属性是x-match，该属性有两个取值（any/all）,any表示发布消息时携带的键值对有一对能匹配上队列定义的其中一个就能，all表示所有的键值对需完全匹配。另外以x-开头的属性不被视作用于路由匹配的属性。</span><br><span class="line">该模式下，交换机和队列绑定需要增加headers值，可通过如下设置：</span><br><span class="line">Map&lt;String, Object&gt; arguments = new HashMap&lt;String, Object&gt;();</span><br><span class="line">arguments.put(&quot;x-match&quot;, &quot;any&quot;);</span><br><span class="line">arguments.put(&quot;arg1&quot;, &quot;a1&quot;);</span><br><span class="line">arguments.put(&quot;latitude&quot;, 51.5252949);</span><br><span class="line">arguments.put(&quot;dataType&quot;, &quot;json&quot;);</span><br><span class="line">channel.queueBind(queueName, EXCHANGE_NAME, &quot;&quot;, arguments);</span><br><span class="line"></span><br><span class="line">使用：</span><br><span class="line">1) 生产者通过如下代码发送消息到Rabbitmq</span><br><span class="line">Map&lt;String, Object&gt; headers = new HashMap&lt;String, Object&gt;();</span><br><span class="line">headers.put(&quot;latitude&quot;,  51.5252949);</span><br><span class="line">headers.put(&quot;longitude&quot;, -0.0905493);</span><br><span class="line">channel.basicPublish(exchangeName, &quot;&quot;,</span><br><span class="line">             new AMQP.BasicProperties.Builder()</span><br><span class="line">               .headers(headers)</span><br><span class="line">               .build(),</span><br><span class="line">               message.getBytes(&quot;UTF-8&quot;));</span><br><span class="line">               </span><br><span class="line">2) 消费者通过channel.basicConsume(queueName, true, (consumerTag, delivery) -&gt; &#123;&#125;, consumerTag -&gt; &#123; &#125;);从Rabbitmq消费消息</span><br></pre></td></tr></table></figure>

<p>默认交换机规则是一个空字符串路由键的直连交换机定义<a href="https://www.rabbitmq.com/tutorials/amqp-concepts.html#exchange-default" target="_blank" rel="noopener">官网</a>，该交换机的路由键与队列键名相同，这使其看起来像是客户端直接提交消息到了队列中。所有新建的队列都天生绑定了这个默认交换机，它的存在也方便了一些简单需求的应用直接使用Rabbitmq。</p>
<h2 id="6-ACK、TRANSACTION、RECOVERY和QOS"><a href="#6-ACK、TRANSACTION、RECOVERY和QOS" class="headerlink" title="6. ACK、TRANSACTION、RECOVERY和QOS"></a>6. ACK、TRANSACTION、RECOVERY和QOS</h2><h3 id="ACK、TRANSACTION和RECOVERY"><a href="#ACK、TRANSACTION和RECOVERY" class="headerlink" title="ACK、TRANSACTION和RECOVERY"></a>ACK、TRANSACTION和RECOVERY</h3><p>​        消费者消费队列消息时，过程中可能由于网络原因或业务原因，出现连接断开或者消费者未接收到消息或者消费者不能成功处理消息，这个时候可能会导致数据的丢失。基于这一点，Rabbitmq提供了，TRANSACRION机制、ACK机制和RECOVERY机制。</p>
<p>​        RECOVERY机制：Rabbitmq JAVA客户端提供连接恢复的功能，在启用该功能时，当客户端由于网络问题断开，会自动恢复客户端，包括恢复连接、恢复连接监听器、重新打开信道及监听器、恢复QOS设置、重新声明交换机、重新声明队列、恢复绑定和消费者，可以通过<code>factory.setAutomaticRecoveryEnabled(true)</code>来打开RECOVERY机制。</p>
<p>​        ACK机制：Rabbitmq提供了交付确认机制，可以设定自动确认交付和手动确认交付。消费者消费消息时的<code>channel.basicConsume</code>方法，第二个参数<code>autoAck</code>为<code>true</code>时表示自动确认交付，为<code>false</code>时表示手动确认交付。自动确认交付模式下，消费者从队列消费消息时立即确认交付，这时队列中立即完全删除该消息。手动确认交付模式下，客户端需告诉服务端是否确认交付，共有三种交付状态：ACK、NACK、REJECT，当客户端发送ACK时表示客户端处理成功，这时Rabbitmq才会完全删除，ACK的调用为<code>channel.basicAck(deliveryTag, false)</code>。当客户端发送NACK和REJECT时均表示交付失败，区别时NACK能批量操作，REJECT的调用为<code>channel.basicReject(deliveryTag, false)</code>，NACK的调用为<code>channel.basicNack(deliveryTag, true, true)</code>，NACK和REJECT的最后一个参数均表示交付失败的是否重新进入队列，ACK和NACK的第二个参数均表示是否包含所有未回复的交付（即是否批量回复）。</p>
<p>​        TRANSACTION机制：Rabbitmq在AMQP协议下提供了事务机制，客户端使用<code>channel.txSelect()</code>方法开启事务，使用<code>channel.txCommit()</code>方法提交事务，使用<code>channel.txRollback()</code>方法回滚事务。该机制是重量级的，并且不是必要的，根据官网的说法，它将导致吞吐量降低250倍，因此官方后面添加了也能保证数据不丢失的ACK机制。</p>
<h3 id="QOS"><a href="#QOS" class="headerlink" title="QOS"></a>QOS</h3><p>默认情况下，消费者一次会尽可能多的消费消息（根据客户端内存），设置QOS可以指定一次最高的消费量，可以使用<code>channel.basicQos(prefetchCount)</code>方法来设置。</p>
<h2 id="7-可视化界面"><a href="#7-可视化界面" class="headerlink" title="7. 可视化界面"></a>7. 可视化界面</h2><p><code>rabbitmq-plugins enable rabbitmq_management</code>命令用于开启可视化管理界面，之后添加有该权限的用户即可访问15672端口使用 </p>
<h2 id="8-JAVA访问测试"><a href="#8-JAVA访问测试" class="headerlink" title="8. JAVA访问测试"></a>8. JAVA访问测试</h2><p>POM依赖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;com.rabbitmq&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;amqp-client&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;5.6.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="简单HelloWorld"><a href="#简单HelloWorld" class="headerlink" title="简单HelloWorld"></a>简单HelloWorld</h3><p>基于默认交换机，且不设QOS</p>
<p>生产者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">import com.rabbitmq.client.Channel;</span><br><span class="line">import com.rabbitmq.client.Connection;</span><br><span class="line">import com.rabbitmq.client.ConnectionFactory;</span><br><span class="line">public class Send &#123;</span><br><span class="line">    private final static String QUEUE_NAME = &quot;hello&quot;,</span><br><span class="line">			ROUTING_KEY = QUEUE_NAME;</span><br><span class="line">	private static ConnectionFactory factory;</span><br><span class="line">	private static Connection conn;</span><br><span class="line">	private static synchronized Channel createConnectChannel() &#123;</span><br><span class="line">		if (factory == null) &#123;</span><br><span class="line">			factory = new ConnectionFactory();</span><br><span class="line">			factory.setHost(&quot;118.25.54.197&quot;);</span><br><span class="line">			factory.setVirtualHost(&quot;test&quot;);</span><br><span class="line">			factory.setUsername(System.getProperty(&quot;username&quot;));</span><br><span class="line">			factory.setPassword(System.getProperty(&quot;password&quot;));</span><br><span class="line">		&#125;</span><br><span class="line">		if (conn == null) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				conn = factory.newConnection();</span><br><span class="line">			&#125; catch(Exception e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		try &#123;</span><br><span class="line">			Channel channel = conn.createChannel();</span><br><span class="line">			return channel;</span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		throw new RuntimeException(&quot;create failed&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	private static void closeChannel(Channel channel) &#123;</span><br><span class="line">		if (channel == null || !channel.isOpen()) return;</span><br><span class="line">		synchronized (channel) &#123;</span><br><span class="line">			if (channel.isOpen()) &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					channel.close();</span><br><span class="line">				&#125; catch (IOException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125; catch (TimeoutException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	private static synchronized void closeConnection(Channel channel) &#123;</span><br><span class="line">		closeChannel(channel);</span><br><span class="line">		if (conn != null &amp;&amp; conn.isOpen()) &#123;</span><br><span class="line">			synchronized (conn) &#123;</span><br><span class="line">				if (conn != null &amp;&amp; conn.isOpen()) &#123;</span><br><span class="line">					try &#123;</span><br><span class="line">						conn.close();</span><br><span class="line">						conn = null;</span><br><span class="line">					&#125; catch (IOException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    public static void main(String[] argv) throws Exception &#123;</span><br><span class="line">        Channel channel = createConnectChannel();</span><br><span class="line">		</span><br><span class="line">		channel.queueDeclare(QUEUE_NAME, false, false, false, null);</span><br><span class="line">		System.out.println(declare);</span><br><span class="line">		String message = &quot;Hello World...&quot;;</span><br><span class="line">		channel.basicPublish(&quot;&quot;, ROUTING_KEY, null, message.getBytes());</span><br><span class="line">		</span><br><span class="line">		System.out.println(&quot; [x] Sent &apos;&quot; + message + &quot;&apos;&quot;);</span><br><span class="line">		closeConnection(channel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import com.rabbitmq.client.Channel;</span><br><span class="line">import com.rabbitmq.client.Connection;</span><br><span class="line">import com.rabbitmq.client.ConnectionFactory;</span><br><span class="line">import com.rabbitmq.client.DeliverCallback;</span><br><span class="line"></span><br><span class="line">public class Recv &#123;</span><br><span class="line">    private final static String QUEUE_NAME = &quot;hello&quot;;</span><br><span class="line">    ...</span><br><span class="line">    public static void main(String[] argv) throws Exception &#123;</span><br><span class="line">        Channel channel = createConnectChannel();</span><br><span class="line">		</span><br><span class="line">		channel.queueDeclare(QUEUE_NAME, false, false, false, null);</span><br><span class="line">		</span><br><span class="line">		System.out.println(&quot; [*] Waiting for messages. To exit press CTRL+C&quot;);</span><br><span class="line">		</span><br><span class="line">		CountDownLatch cdl = new CountDownLatch(1);</span><br><span class="line">		DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            String message = new String(delivery.getBody(), &quot;UTF-8&quot;);</span><br><span class="line">            System.out.println(&quot; [x] Received &apos;&quot; + message + &quot;&apos;&quot;);</span><br><span class="line">            cdl.countDown();</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(QUEUE_NAME, true, deliverCallback, consumerTag -&gt; &#123; &#125;);</span><br><span class="line">        </span><br><span class="line">        cdl.await();</span><br><span class="line">        closeConnection(channel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多个消费者"><a href="#多个消费者" class="headerlink" title="多个消费者"></a>多个消费者</h3><p>基于设QOS且存在ACK的情况</p>
<p>生产者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class RabbitQueueProducer &#123;</span><br><span class="line">	...</span><br><span class="line">	public static void main(String[] args) throws IOException &#123;</span><br><span class="line">		Channel channel = createConnectChannel();</span><br><span class="line">		channel.queueDeclare(QUEUE_NAME, false, false, false, null);</span><br><span class="line">		</span><br><span class="line">		Scanner sc = new Scanner(System.in);</span><br><span class="line">		String nextLine = sc.nextLine();</span><br><span class="line">		sc.close();</span><br><span class="line">		if (!nextLine.contains(&quot;.&quot;)) nextLine += &quot;.&quot;;</span><br><span class="line"></span><br><span class="line">		String message = String.join(&quot;&quot;, nextLine);</span><br><span class="line">		</span><br><span class="line">		channel.basicPublish(&quot;&quot;, QUEUE_NAME, MessageProperties.PERSISTENT_TEXT_PLAIN, message.getBytes());</span><br><span class="line">		System.out.println(&quot; [x] Sent &apos;&quot; + message + &quot;&apos;&quot;);</span><br><span class="line">		closeConnection(channel);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public class RabbitQueueConsumer &#123;</span><br><span class="line">	...</span><br><span class="line">	private static SimpleDateFormat sdf = new SimpleDateFormat(&quot;HH:mm:ss.SSS&quot;);</span><br><span class="line">	private static void doWork(String task) &#123;</span><br><span class="line">		for (char ch : task.toCharArray()) &#123;</span><br><span class="line">			if (ch == &apos;.&apos;) &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					Thread.sleep(1000l);</span><br><span class="line">				&#125; catch (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">					Thread.currentThread().interrupt();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static void main(String[] args) throws IOException, InterruptedException &#123;</span><br><span class="line">		Channel channel = createConnectChannel();</span><br><span class="line">		channel.queueDeclare(QUEUE_NAME, false, false, false, null);</span><br><span class="line">		Thread.sleep(4000l);</span><br><span class="line">		channel.basicQos(1);</span><br><span class="line">		CountDownLatch cdl = new CountDownLatch(1);</span><br><span class="line">		DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            String message = new String(delivery.getBody(), &quot;UTF-8&quot;);</span><br><span class="line">            long deliveryTag = delivery.getEnvelope().getDeliveryTag();</span><br><span class="line">            System.out.println(&quot; [!] Delivery TAG &apos;&quot; + deliveryTag + &quot;&apos;&quot;);</span><br><span class="line">            System.out.println(&quot; [x] Received &apos;&quot; + message + &quot;&apos;&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">            	doWork(message);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">            	System.out.println(&quot; [x] Done&quot;);</span><br><span class="line">            	channel.basicNack(delivery.getEnvelope().getDeliveryTag(), false, false);</span><br><span class="line">            &#125;</span><br><span class="line">            boolean ack = Math.random() &gt; 0.5;</span><br><span class="line">            System.out.println(&quot; [a] ACK &apos;&quot; + ack + &quot;&apos; &quot; + sdf.format(new Date()));</span><br><span class="line">            if (ack) &#123;</span><br><span class="line">            	channel.basicAck(deliveryTag, false);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">            	channel.basicNack(deliveryTag, false, true);</span><br><span class="line">            &#125;</span><br><span class="line">            cdl.countDown();</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(&quot; [*] Waiting for messages  &quot; + sdf.format(new Date()));</span><br><span class="line">        channel.basicConsume(QUEUE_NAME, false, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">        	System.out.println(&quot; [x] Cancel &apos;&quot; + consumerTag + &quot;&apos;&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">        cdl.await();</span><br><span class="line">        closeConnection(channel);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Fanout"><a href="#Fanout" class="headerlink" title="Fanout"></a>Fanout</h3><p>生产者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class RabbitFanoutProducer &#123;	</span><br><span class="line">	private final static String EXCHANGE_NAME = &quot;fanout&quot;;</span><br><span class="line">	private final static String ROUTING_KEY = &quot;&quot;;</span><br><span class="line">	...</span><br><span class="line">	public static void main(String[] args) throws IOException &#123;</span><br><span class="line">		Channel channel = createConnectChannel();</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		Scanner sc = new Scanner(System.in);</span><br><span class="line">		System.out.println(&quot; [!] Enter Message&quot;);</span><br><span class="line">		String nextLine = sc.nextLine();</span><br><span class="line">		sc.close();</span><br><span class="line">		if (!nextLine.contains(&quot;.&quot;)) nextLine += &quot;.&quot;;</span><br><span class="line"></span><br><span class="line">		String message = String.join(&quot;&quot;, nextLine);</span><br><span class="line">		</span><br><span class="line">		channel.basicPublish(EXCHANGE_NAME, ROUTING_KEY, null, message.getBytes());</span><br><span class="line">		</span><br><span class="line">		System.out.println(&quot; [x] Sent &apos;&quot; + message + &quot;&apos;&quot;);</span><br><span class="line">		closeConnection(channel);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class RabbitFanoutConsumer &#123;</span><br><span class="line">	private final static String EXCHANGE_NAME = &quot;fanout&quot;;</span><br><span class="line">	private final static String ROUTING_KEY = &quot;&quot;;</span><br><span class="line">	...</span><br><span class="line">	public static void main(String[] args) throws IOException, InterruptedException &#123;</span><br><span class="line">		Channel channel = createConnectChannel();</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		Scanner sc = new Scanner(System.in);</span><br><span class="line">		System.out.println(&quot; [!] Enter Queue Name&quot;);</span><br><span class="line">		String queueName = sc.nextLine();</span><br><span class="line">		sc.close();</span><br><span class="line">		</span><br><span class="line">		channel.queueDeclare(queueName, false, false, false, null);</span><br><span class="line">		channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT);</span><br><span class="line">		channel.queueBind(queueName, EXCHANGE_NAME, ROUTING_KEY);</span><br><span class="line">		</span><br><span class="line">		System.out.println(&quot; [*] Waiting for messages. To exit press CTRL+C&quot;);</span><br><span class="line">		</span><br><span class="line">		CountDownLatch cdl = new CountDownLatch(3);</span><br><span class="line">		DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            String message = new String(delivery.getBody(), &quot;UTF-8&quot;);</span><br><span class="line">            </span><br><span class="line">            System.out.println(&quot; [x] Received &apos;&quot; + message + &quot;&apos;&quot;);</span><br><span class="line">            cdl.countDown();</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(queueName, true, deliverCallback, consumerTag -&gt; &#123; &#125;);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        cdl.await();</span><br><span class="line">        closeConnection(channel);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://page.uetty.com/2019/04/22/rabbitmq/" data-id="ck5qhi07k002xg0uknlwwmuix" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RabbitMQ/">RabbitMQ</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/05/18/idea-experience/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          IDEA配置经验与问题解决
        
      </div>
    </a>
  
  
    <a href="/2019/03/07/lock-opinion/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">多线程死锁分析与加锁原则观点</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/IDE/">IDE</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MyBatis/">MyBatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RabbitMQ/">RabbitMQ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/api/">api</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/">css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dubbo/">dubbo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/encoding/">encoding</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/log4j/">log4j</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/maven/">maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/open-source/">open source</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/">spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vulnerability/">vulnerability</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/图论/">图论</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/IDE/" style="font-size: 10px;">IDE</a> <a href="/tags/MyBatis/" style="font-size: 10px;">MyBatis</a> <a href="/tags/RabbitMQ/" style="font-size: 10px;">RabbitMQ</a> <a href="/tags/api/" style="font-size: 12.5px;">api</a> <a href="/tags/css/" style="font-size: 10px;">css</a> <a href="/tags/docker/" style="font-size: 10px;">docker</a> <a href="/tags/dubbo/" style="font-size: 10px;">dubbo</a> <a href="/tags/encoding/" style="font-size: 10px;">encoding</a> <a href="/tags/java/" style="font-size: 20px;">java</a> <a href="/tags/linux/" style="font-size: 17.5px;">linux</a> <a href="/tags/log4j/" style="font-size: 10px;">log4j</a> <a href="/tags/maven/" style="font-size: 10px;">maven</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/open-source/" style="font-size: 10px;">open source</a> <a href="/tags/redis/" style="font-size: 10px;">redis</a> <a href="/tags/spring/" style="font-size: 15px;">spring</a> <a href="/tags/vulnerability/" style="font-size: 10px;">vulnerability</a> <a href="/tags/图论/" style="font-size: 10px;">图论</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">2020-03</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">2020-02</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">2020-01</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">2019-12</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">2019-11</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">2019-08</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">2019-07</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">2019-06</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">2019-05</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">2019-04</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">2019-03</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">2019-02</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">2018-12</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">2018-11</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">2018-10</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">2018-09</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">2018-08</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">2018-06</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">2018-03</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">2018-02</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">2017-12</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">2017-09</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">2017-08</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">2017-07</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">2017-05</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">2017-03</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/03/15/innodb-struct/">了解InnoDB体系架构</a>
          </li>
        
          <li>
            <a href="/2020/02/23/bipartite-graph/">从二分图开始到最大匹配</a>
          </li>
        
          <li>
            <a href="/2020/02/13/character-set-encoding/">理解字符集编码及Java内存编码运行机制</a>
          </li>
        
          <li>
            <a href="/2020/01/08/gitlab-api/">Gitlab Api</a>
          </li>
        
          <li>
            <a href="/2019/12/11/source-bitcount/">JDK中Integer.bitCount解析</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Vince<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>