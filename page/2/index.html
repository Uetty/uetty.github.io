<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>Vince Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Vince Blog">
<meta property="og:url" content="https://www.uetty.com/page/2/index.html">
<meta property="og:site_name" content="Vince Blog">
<meta property="og:locale" content="zh_CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Vince Blog">
  
    <link rel="alternate" href="/atom.xml" title="Vince Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Vince Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//www.baidu.com/s" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q1" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="q6" value="www.uetty.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-lock-opinion" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/07/lock-opinion/" class="article-date">
  <time datetime="2019-03-07T13:51:20.000Z" itemprop="datePublished">2019-03-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/07/lock-opinion/">多线程死锁分析与加锁原则观点</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li>单条线程只同时持有一个锁的情况下，无论多少条线程肯定不会造成死锁</li>
<li>同时持有多个锁的代码，只要不出现持锁顺序（考虑传递性）相反的情况，无论多少条线程肯定不会出现死锁<h1 id="死锁分析"><a href="#死锁分析" class="headerlink" title="死锁分析"></a>死锁分析</h1><h2 id="非传递性持锁顺序相反的死锁案例"><a href="#非传递性持锁顺序相反的死锁案例" class="headerlink" title="非传递性持锁顺序相反的死锁案例"></a>非传递性持锁顺序相反的死锁案例</h2><img src="../static/MB19030701-1.png" alt="MB19030701-1.png"></li>
</ol>
<p>线程1持有锁a等待锁b，线程2持有锁b等待锁a。这种情况下的分析，线程1上锁的顺序是ab，线程2上锁的顺序是ba，持锁顺序相反，代码运行到特定的点会导致死锁的情况出现</p>
<h2 id="传递性下的持锁顺序相反的死锁案例"><a href="#传递性下的持锁顺序相反的死锁案例" class="headerlink" title="传递性下的持锁顺序相反的死锁案例"></a>传递性下的持锁顺序相反的死锁案例</h2><p><img src="../static/MB19030701-2.png" alt="MB19030701-2.png"></p>
<p>线程1持有锁a等待锁b，线程2持有锁b等待锁c，线程3持有锁c等待锁a。这种情况，就是传递性情况下持锁顺序相反导致的死锁（就是我们通常说的构成了闭环）。线程1上锁的顺序是ab，线程2上锁的顺序是bc，线程3持锁的顺序为ca。这种情况下的分析，考虑作并线处理分析。将线程1与线程2并线分析，则他们并线后持锁顺序是abc，而线程3的持锁顺序是ca，这里面两边ac锁的顺序相反，代码运行到特定的点会导致死锁的情况出现</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://www.uetty.com/2019/03/07/lock-opinion/" data-id="ck0v87sna001alwuk2mry506c" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-source-hashmap" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/28/source-hashmap/" class="article-date">
  <time datetime="2019-02-28T13:48:24.000Z" itemprop="datePublished">2019-02-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/28/source-hashmap/">HashMap源码阅读笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="tableSizeFor方法"><a href="#tableSizeFor方法" class="headerlink" title="tableSizeFor方法"></a>tableSizeFor方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static final int tableSizeFor(int cap) &#123;</span><br><span class="line">        int n = cap - 1;</span><br><span class="line">        n |= n &gt;&gt;&gt; 1;</span><br><span class="line">        n |= n &gt;&gt;&gt; 2;</span><br><span class="line">        n |= n &gt;&gt;&gt; 4;</span><br><span class="line">        n |= n &gt;&gt;&gt; 8;</span><br><span class="line">        n |= n &gt;&gt;&gt; 16;</span><br><span class="line">        return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>由公式：<code>(a|b)&gt;&gt;&gt;k = (a&gt;&gt;&gt;k)|(b&gt;&gt;&gt;k)</code> 及<code>a|b|b = a|b</code>及交换律得到一个推论： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">若a = n&gt;&gt;&gt;0|n&gt;&gt;&gt;1|n&gt;&gt;&gt;2|n&gt;&gt;&gt;3|....|n&gt;&gt;&gt;(2的k次方-1) ，那么a | a &gt;&gt;&gt; (2的k次方) = n &gt;&gt;&gt; (2的k+1次方 - 1)</span><br></pre></td></tr></table></figure>

<p>所以上面的<code>n&gt;&gt;&gt;1</code>到<code>n&gt;&gt;&gt;16</code>部分的代码计算相当于求 <code>n|n&gt;&gt;&gt;1|n&gt;&gt;&gt;2|n&gt;&gt;&gt;3|...|n&gt;&gt;&gt;31</code>(n取原始值），即得到的数为二进制包含最高位以下的位全部置1，例如：若n=15=0b1111，最终得到0b1111=15；若n=12=0b1100，最终得到0b1111=15；若n=0b0101，最终得到0b0111=7</p>
<h2 id="resize方法"><a href="#resize方法" class="headerlink" title="resize方法"></a>resize方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        int oldCap = (oldTab == null) ? 0 : oldTab.length;</span><br><span class="line">        int oldThr = threshold;</span><br><span class="line">        int newCap, newThr = 0;</span><br><span class="line">        if (oldCap &gt; 0) &#123;</span><br><span class="line">            if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;  // 实际数量超过Integer.MAX_VALUE的一半，数组的容量设为Integer.MAX_VALUE</span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                return oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            // 数组容量翻倍，并且旧的容量不小于于初始容量时，同时也将阈值翻倍</span><br><span class="line">            else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                newThr = oldThr &lt;&lt; 1; // double threshold</span><br><span class="line">        &#125;</span><br><span class="line">        else if (oldThr &gt; 0) // 新建类时有设置阈值但没设置数组容量，则以阈值作为容量</span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        else &#123;               // 新建时什么都没有设置，给默认值：16 和 16 * 0.75</span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        if (newThr == 0) &#123; // 检查阈值设置，未设置时由 容量阈值比和容量乘积计算</span><br><span class="line">            float ft = (float)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (int)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold = newThr;</span><br><span class="line">        @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">        table = newTab;</span><br><span class="line">        // 扩容后重新放置节点</span><br><span class="line">        if (oldTab != null) &#123;</span><br><span class="line">            for (int j = 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                if ((e = oldTab[j]) != null) &#123;</span><br><span class="line">                    oldTab[j] = null;</span><br><span class="line">                    if (e.next == null) // 数组位置的树只有一个节点，扩容后，新位置当然也只有一个节点</span><br><span class="line">                        newTab[e.hash &amp; (newCap - 1)] = e;</span><br><span class="line">                    else if (e instanceof TreeNode) // 数组+树结构时，执行树的分割</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">                    else &#123; // 数组+链表时，链表分割为两份，直接比较扩容后(capacity - 1)的值新增加的那一位即可知道分割到哪一部分</span><br><span class="line">                        Node&lt;K,V&gt; loHead = null, loTail = null;    // 分割到低位上的节点的头与尾</span><br><span class="line">                        Node&lt;K,V&gt; hiHead = null, hiTail = null;    // 分割到高位上的节点的头和尾</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        do &#123;</span><br><span class="line">                            next = e.next;</span><br><span class="line">                            if ((e.hash &amp; oldCap) == 0) &#123; // hash值对应于新扩容后的位（oldCap刚好是新扩容的长度的新增位，实际上应写为(newCap - 1 - (oldCap - 1))的值，由于刚好等于oldCap所以就减少了计算）的值是0，分割到0值的那一部分</span><br><span class="line">                                if (loTail == null)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                else</span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            else &#123;   // hash值对应于(newCap - 1)的新的位的值为1，分割到1值的那一部分</span><br><span class="line">                                if (hiTail == null)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                else</span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; while ((e = next) != null);</span><br><span class="line">                        if (loTail != null) &#123;</span><br><span class="line">                            loTail.next = null;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (hiTail != null) &#123;</span><br><span class="line">                            hiTail.next = null;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="TreeNode结构"><a href="#TreeNode结构" class="headerlink" title="TreeNode结构"></a>TreeNode结构</h2><p>HashMap在数据量较小时，使用的数组+链表的结构，当数据量较大时使用数组+树的结构。由数组+链表到数组+树的结构的转化，在于<code>treeifyBin</code>方法。当链表的长度大于7时，会触发<code>treeifyBin</code>方法判断是否转变存储结构，当数组的长度也大于63时，即会使该hash值的链表结构变更为树结构。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://www.uetty.com/2019/02/28/source-hashmap/" data-id="ck0v87sn90019lwuksrab3zca" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-jvm-heap-stack" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/17/jvm-heap-stack/" class="article-date">
  <time datetime="2019-02-17T02:49:00.000Z" itemprop="datePublished">2019-02-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/17/jvm-heap-stack/">JVM堆栈笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ol>
<li>堆内存默认新生代和老年代空间占比：1 : 2</li>
<li>新生代中默认单个Survivor区和Eden区的空间占比：1 : 8</li>
<li><a href="https://blog.csdn.net/leunging/article/details/80599282" target="_blank" rel="noopener">https://blog.csdn.net/leunging/article/details/80599282</a></li>
</ol>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ol>
<li><p>-Xms        堆内存初始大小（记忆方式，m以内存的单词memory记忆，s以small记忆，想象一下衣服的尺号就好记了），使用时：-Xms256m</p>
</li>
<li><p>-Xmx        堆内存最大大小（记忆方式同上，最后一个x以extra记忆，同样想象下衣服的加大号就好记了）</p>
</li>
<li><p>-Xmn        堆内存中新生代的最大内存和初始内存设为一致的值了，不再变化（记忆方式同上，n使用new记忆）</p>
</li>
<li><p>-XX:NewSize        堆内存中新生代的初始内存，使用时：-XX:NewSize=256m</p>
</li>
<li><p>-XX:MaxNewSize        堆内存中新生代的最大内存</p>
</li>
<li><p>-Xss(或-XX:ThreadStackSize)        每个线程的栈内存的大小（默认1M），该数值影响可以启动的线程的数量，也影响每个线程的栈帧数量（记忆方式，Stack Size）</p>
</li>
<li><p>-XX:+PrintGC(别名-verbose:gc)        打印gc的信息</p>
</li>
<li><p>-XX:+PrintGCTimeStamps        以基准时间的形式打印GC的时间戳</p>
<p>不开启时打印如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure)  155644K-&gt;36463K(402432K), 0.0095270 secs]</span><br></pre></td></tr></table></figure>

<p>开启时打印如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4.609: [GC (Allocation Failure)  162642K-&gt;34898K(396800K), 0.0105201 secs]</span><br></pre></td></tr></table></figure>
</li>
<li><p>-XX:+PrintGCDateStamps        以日期的形式打印GC时间戳（可以设置日期形式和基准形式同时打印）</p>
<p>开启时打印如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2019-02-25T09:36:33.424+0800: [GC (Allocation Failure)  155673K-&gt;36616K(397824K), 0.0084967 secs]</span><br></pre></td></tr></table></figure>

<p>同时开启时打印如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2019-02-25T09:38:16.009+0800: 6.488: [GC (Allocation Failure)  169212K-&gt;42272K(518656K), 0.0163488 secs]</span><br></pre></td></tr></table></figure>
</li>
<li><p>-XX:+PrintGCDetails        打印gc的详细信息，启动脚本下运行会自动开启-XX:+PrintGC，jinfo附加下运行不会自动开启</p>
<p>开启时打印如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 137517K-&gt;9963K(147456K)] 169528K-&gt;41982K(534528K), 0.0124863 secs] [Times: user=0.04 sys=0.00, real=0.01 secs]</span><br></pre></td></tr></table></figure>
</li>
<li><p>-XX:+PrintHeapAtGC        在进行GC的前后打印出堆的信息</p>
<p>开启时打印如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;Heap before GC invocations=1 (full 0):</span><br><span class="line"> PSYoungGen      total 147456K, used 131072K [0x00000000f6000000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">  eden space 131072K, 100% used [0x00000000f6000000,0x00000000fe000000,0x00000000fe000000)</span><br><span class="line">  from space 16384K, 0% used [0x00000000ff000000,0x00000000ff000000,0x0000000100000000)</span><br><span class="line">  to   space 16384K, 0% used [0x00000000fe000000,0x00000000fe000000,0x00000000ff000000)</span><br><span class="line"> ParOldGen       total 163840K, used 0K [0x0000000087e00000, 0x0000000091e00000, 0x00000000f6000000)</span><br><span class="line">  object space 163840K, 0% used [0x0000000087e00000,0x0000000087e00000,0x0000000091e00000)</span><br><span class="line"> Metaspace       used 14008K, capacity 14230K, committed 14464K, reserved 1062912K</span><br><span class="line">  class space    used 1295K, capacity 1356K, committed 1408K, reserved 1048576K</span><br><span class="line">[GC (Allocation Failure)  131072K-&gt;17089K(311296K), 0.0130938 secs]</span><br><span class="line">Heap after GC invocations=1 (full 0):</span><br><span class="line"> PSYoungGen      total 147456K, used 16366K [0x00000000f6000000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">  eden space 131072K, 0% used [0x00000000f6000000,0x00000000f6000000,0x00000000fe000000)</span><br><span class="line">  from space 16384K, 99% used [0x00000000fe000000,0x00000000feffb9b0,0x00000000ff000000)</span><br><span class="line">  to   space 16384K, 0% used [0x00000000ff000000,0x00000000ff000000,0x0000000100000000)</span><br><span class="line"> ParOldGen       total 163840K, used 723K [0x0000000087e00000, 0x0000000091e00000, 0x00000000f6000000)</span><br><span class="line">  object space 163840K, 0% used [0x0000000087e00000,0x0000000087eb4d20,0x0000000091e00000)</span><br><span class="line"> Metaspace       used 14008K, capacity 14230K, committed 14464K, reserved 1062912K</span><br><span class="line">  class space    used 1295K, capacity 1356K, committed 1408K, reserved 1048576K</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>-Xloggc:/var/log/java/gc.log        指定GC日志的输出文件</p>
</li>
<li><p>-XX:SurvivorRatio        Eden区和Survivor区的内存比值</p>
</li>
<li><p>-XX:NewRatio        老年代和新生代的内存比值</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://www.uetty.com/2019/02/17/jvm-heap-stack/" data-id="ck0v87sn60014lwuk2ryw6tsc" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-source-countdownlatch" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/09/source-countdownlatch/" class="article-date">
  <time datetime="2019-02-09T07:05:55.000Z" itemprop="datePublished">2019-02-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/09/source-countdownlatch/">CountDownLatch源码阅读</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="await方法如何实现线程等待"><a href="#await方法如何实现线程等待" class="headerlink" title="await方法如何实现线程等待"></a>await方法如何实现线程等待</h2><p><code>await</code>方法，由<code>CountDownLatch.Sync.acquireSharedInterruptibly</code>代理完成，实际上由Sync的父类<code>AbstractQueuedSynchronizer</code>实现了该方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final void acquireSharedInterruptibly(int arg)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于arg参数入参固定为1, 而Sync实现的<code>tryAcquireShared</code>方法对于入参数1返回-1，因此实际相当于调用了如下代码，<code>Thread.interrupted</code>确保了当前线程不是interrupted的状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public final void acquireSharedInterruptibly(int arg)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AbstractQueuedSynchronizer</code>类的<code>doAcquireSharedInterruptibly</code>方法，其中<code>addWaiter</code>方法是往Node链表最后增加一个Node节点并返回该节点，Node对象中存储了当前线程t</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private void doAcquireSharedInterruptibly(int arg)</span><br><span class="line">    throws InterruptedException &#123;</span><br><span class="line">    final Node node = addWaiter(Node.SHARED);</span><br><span class="line">    boolean failed = true;</span><br><span class="line">    try &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            final Node p = node.predecessor();</span><br><span class="line">            if (p == head) &#123;</span><br><span class="line">                int r = tryAcquireShared(arg);</span><br><span class="line">                if (r &gt;= 0) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = null; // help GC</span><br><span class="line">                    failed = false;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                throw new InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上由于arg值固定为1，上面方法相当于如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private void doAcquireSharedInterruptibly(int arg)</span><br><span class="line">    throws InterruptedException &#123;</span><br><span class="line">    final Node node = addWaiter(Node.SHARED);</span><br><span class="line">    boolean failed = true;</span><br><span class="line">    try &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            final Node p = node.predecessor();</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                throw new InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>shouldParkAfterFailedAcquire</code>方法判断当前新增的节点（node）的前置节点（p）是否持有信号，并在没有持有信号的情况下，使其变更为持有信号状态（使state值设为SIGNAL）。<code>doAcquireSharedInterruptibly</code>中for循环直到<code>shouldParkAfterFailedAcquire</code>方法判断node的前置节点持有信号时，才会调用<code>parkAndCheckInterrupt</code>方法。</p>
<p><code>parkAndCheckInterrupt</code>代码便是阻塞代码真正所在的位置，该功方法代码很简单，直接委托<code>LockSupport.park(this)</code>完成，<code>LockSupport.park(this)</code>代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void park(Object blocker) &#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    setBlocker(t, blocker);</span><br><span class="line">    UNSAFE.park(false, 0L);</span><br><span class="line">    setBlocker(t, null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>setBlocker</code>时native的方法，它的作用是将第二个参数存储在第一个参数（线程）的堆内存中（即这是一个直接操作堆内存存储的实现），上面<code>park</code>方法中<code>UNSAFE.park</code>为阻塞功能的实现，点进去看发现也是一个native修饰的方法，即真正阻塞功能的还是由底层实现的，没法看到具体的代码。</p>
<h2 id="countDown方法如何实现计数递减并取消阻塞"><a href="#countDown方法如何实现计数递减并取消阻塞" class="headerlink" title="countDown方法如何实现计数递减并取消阻塞"></a>countDown方法如何实现计数递减并取消阻塞</h2><p>与<code>await</code>方法一样，<code>countDown</code>方法也是将工作委托给了Sync类的方法完成。<code>CountDownLatch.Sync.releaseShared</code>代理完成该功能，<code>CountDownLatch.Sync.releaseShared</code>实际上也是已经由Sync的父类<code>AbstractQueuedSynchronizer</code>实现了，该方法如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line">    if (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tryReleaseShared</code>方法尝试进行计数（即<code>state</code>）递减，<code>tryReleaseShared</code>方法中与前面一些方法一样，使用了原子性的方法<code>compareAndSetState</code>完成递减操作，该原子性操作保证了不会出现两次countDown之后<code>state</code>只递减一次的情况。当本次递减后计数达到0返回true，原先计数已经为0或者本次递减后计数不为0，返回false。<code>tryReleaseShared</code>返回true后，才能调用<code>doReleaseShared</code>完成Node恢复阻塞的线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected boolean tryReleaseShared(int releases) &#123;</span><br><span class="line">    // Decrement count; signal when transition to zero</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int c = getState();</span><br><span class="line">        if (c == 0)</span><br><span class="line">            return false;</span><br><span class="line">        int nextc = c-1;</span><br><span class="line">        if (compareAndSetState(c, nextc))</span><br><span class="line">            return nextc == 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如下所示为<code>doReleaseShared</code>方法代码，当<code>ws == Node.SIGNAL</code>（持有信号）时，调用<code>compareAndSetWaitStatus</code>尝试使Node不再持有信号（state值从SIGNAL变为0，<code>compareAndSetWaitStatus</code>调用的<code>unsafe.compareAndSwapInt</code>方法是原子性的方法），释放信号成功则进行<code>unparkSuccessor</code>的调用，不成功则继续循环（一般另外一条线程同时操作这个node的时候才会导致不成功），当<code>ws == 0</code>时，将该Node标识转为PROPAGATE后不再作处理，这种情况基本与<code>CountDownLatch</code>的业务无关，只是<code>AbstractQueuedSynchronizer</code>对Node链表结构的维护工作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private void doReleaseShared() &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        if (h != null &amp;&amp; h != tail) &#123;</span><br><span class="line">            int ws = h.waitStatus;</span><br><span class="line">            if (ws == Node.SIGNAL) &#123;</span><br><span class="line">                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))</span><br><span class="line">                    continue;            // loop to recheck cases</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            else if (ws == 0 &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))</span><br><span class="line">                continue;                // loop on failed CAS</span><br><span class="line">        &#125;</span><br><span class="line">        if (h == head)                   // loop if head changed</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后<code>unparkSuccessor</code>方法，找到head Node的下一个Node s，找到阻塞的线程<code>s.thread</code>， 调用<code>LockSupport.unpark(s.thread)</code>解除线程阻塞（核心代码<code>UNSAFE.unpark(thread)</code>方法，是native方法，发现一点有意思的情况：该方法运行完会改变head的指向，虽然与这里研究的关系不大，但传入参数是thread却能改变Sync的head Node指针确是挺有意思的）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private void unparkSuccessor(Node node) &#123;</span><br><span class="line">        </span><br><span class="line">        int ws = node.waitStatus;</span><br><span class="line">        if (ws &lt; 0)</span><br><span class="line">            compareAndSetWaitStatus(node, ws, 0);</span><br><span class="line"></span><br><span class="line">        Node s = node.next;</span><br><span class="line">        if (s == null || s.waitStatus &gt; 0) &#123;</span><br><span class="line">            s = null;</span><br><span class="line">            for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)</span><br><span class="line">                if (t.waitStatus &lt;= 0)</span><br><span class="line">                    s = t;</span><br><span class="line">        &#125;</span><br><span class="line">        if (s != null)</span><br><span class="line">            LockSupport.unpark(s.thread);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>CountDownLatch基本由<code>CountDownLatch.Sync</code>代理，Sync大量调用了<code>sun.misc.Unsafe</code>的代码。使用Unsafe的用于改变变量值的原子性方法，减少一些锁的使用；另外一点是使用park和<code>sun.misc.Unsaft.park</code>和<code>sun.misc.Unsaft.unpark</code>方法来实现指定线程的阻塞与解除阻塞。可惜的是<code>sun.misc.Unsafe</code>类oracle并不开放给外部代码使用。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://www.uetty.com/2019/02/09/source-countdownlatch/" data-id="ck0v87sn80016lwukx39o1rxj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-iptables" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/30/iptables/" class="article-date">
  <time datetime="2018-12-30T08:13:02.000Z" itemprop="datePublished">2018-12-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/30/iptables/">iptables 笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="iptables-笔记"><a href="#iptables-笔记" class="headerlink" title="iptables 笔记"></a>iptables 笔记</h1><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="../static/MB18123001-1.png" alt="iptables总体"></p>
<h2 id="iptables命令"><a href="#iptables命令" class="headerlink" title="iptables命令"></a>iptables命令</h2><p>显示列表：<code>iptables -t filter -L -n</code>      -t参数指定显示哪个链，默认filter链，加-v显示更详细信息，可看到哪张网卡流入流出 </p>
<p>清空设置：<code>iptables -F</code> </p>
<p>阻止特定源ip（111.111.11.11）对目的ip（10.18.139.82）的8080端口访问：<code>iptables -I DOCKER -s 111.111.11.11 -d 10.18.139.82 -p TCP --dport 8080 -j DROP</code>  </p>
<p>添加一条开放端口的规则： <code>iptables -A INPUT -p tcp --dport 22 -j ACCEPT</code>  -A表示添加规则 </p>
<p>替换一条规则为开放220端口：<code>iptables -R INPUT 1 -p tcp --dport 220 -j ACCEPT</code> -R表示替换规则，<code>INPUT 1</code>表示INPUT链路的第1条规则，规则行号用<code>iptables -L -n --line-number</code>命令查看 </p>
<p>插入一条规则：<code>iptables -I INPUT 3 -p tcp --dport 220 -j ACCEPT</code>  -I表示插入规则</p>
<p>添加一条禁止端口的规则： <code>iptables -A INPUT -p tcp --dport 8080 -j DROP</code> </p>
<p>删除一条规则：先使用 <code>iptables -L -n --line-number</code> 查看number，之后使用<code>iptables -D INPUT 3</code> 删除number号对应的规则 </p>
<p>通常设置只通过部分端口的规则需要设置允许换回链路，以及允许主动访问外网时外网的响应流量流入：<code>iptables -A INPUT -i lo -j ACCEPT</code>、<code>iptables -A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT</code>，第一条为环回链路，第二条为以连接或程序启动的向外端口允许流入</p>
<p>设置环回链路规则时，通过<code>iptable -L -n</code>命令看到不到详细信息会误以为通过了全部端口，使用<code>iptables -L -n -v</code>命令看详细信息，才可看到实际规则</p>
<p>一个规则里设置多个端口：<code>iptables -A INPUT -p tcp -m multiport --destination-ports 22,3306,443,80 -j ACCEPT</code></p>
<p>命令里设置iptables规则，重启后将失效，通过<code>iptables-save &gt; /root/iptables.conf</code>保存配置到文件里，重启后使用<code>iptables-restore &lt; /root/iptables.conf</code>恢复配置。如果service iptables可以使用，则可以直接用<code>service iptables save</code>保存 </p>
<h2 id="ip黑名单"><a href="#ip黑名单" class="headerlink" title="ip黑名单"></a>ip黑名单</h2><p>结合使用ipset软件设置ip黑名单</p>
<p>安装软件：<code>apt-get install ipset</code></p>
<p>创建名单：<code>ipset create blacklist hash:net</code>    最后的参数还可以是：<code>hash:ip</code>、<code>hash:ip,port</code>等，名单是以hash方式存储的，所以不会怎么影响性能，hash size默认能存储1024个</p>
<p>创建自动过期的名单：<code>ipset create timoutlist hash:ip timeout 300</code>    300秒后自动过期</p>
<p>添加ip：<code>ipset add blacklist 1.1.1.1</code></p>
<p>添加ip地址段：<code>ipset add blacklist 1.1.1.0/24</code> 前24byte的地址匹配</p>
<p>如果集合是ip,port的形式：<code>ipset add blacklist 1.1.1.1,80</code> 添加1.1.1.1的ip的80端口</p>
<p>查看列表：<code>ipset list</code></p>
<p>查看集合内内容：<code>ipset list blacklist</code></p>
<p>清空所有集合：<code>ipset flush</code></p>
<p>清空单个集合：<code>ipset flush blacklist</code></p>
<p>从集合删除内容：<code>ipset del blacklist x.x.x.x</code></p>
<p>销毁集合：<code>ipset destroy blacklist</code></p>
<p>使用ipset名单：<code>iptables -A INPUT -m set --match-set blacklist src -p tcp -j DROP</code></p>
<p>如果是设置不匹配名单添加<code>!</code>符合即可：<code>iptables -A INPUT -m set ! --match-set blacklist src -p tcp -j DROP</code></p>
<p>保存与恢复：通过<code>ipset save &gt; /root/ipset.conf</code>保存配置到文件里，重使用<code>ipset restore &lt; /root/ipset.conf</code>恢复配置</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://www.uetty.com/2018/12/30/iptables/" data-id="ck0v87sn2000ylwukoh5la436" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-mysql-slave" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/30/mysql-slave/" class="article-date">
  <time datetime="2018-12-30T05:23:29.000Z" itemprop="datePublished">2018-12-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/30/mysql-slave/">MySQL主从同步配置</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>为了方便操作，这里使用docker</p>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ol>
<li><p>创建网桥 <code>docker network create nw-ms</code>  </p>
</li>
<li><p>主MySQL环境：<code>docker run -it --name=master --network=nw-ms --network-alias=master uetty/mysql:5.7.23</code>  </p>
</li>
<li><p><code>vim /etc/mysql/mysql.conf.d/mysqld.cnf</code>  添加两行  </p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server-id               = 1</span><br><span class="line">log_bin                 = /var/log/mysql/mysql-bin.log</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启MySQL <code>service mysql restart</code> </p>
</li>
<li><p>退出容器    <code>ctrl + p &amp;&amp; ctrl + q</code>  </p>
</li>
<li><p>从MySQL环境：<code>docker run -it --name=slave --network=nw-ms --network-alias=slave uetty/mysql:5.7.23</code>  </p>
</li>
<li><p><code>vim /etc/mysql/mysql.conf.d/mysqld.cnf</code>  添加两行<br><code>server-id               = 100</code><br><code>log_bin                 = /var/log/mysql/mysql-bin.log</code>  </p>
</li>
<li><p>修改从服务器UUID使其不跟主服务器一样（使用docker部署同一台机子上会出现uuid一样的情况）<code>vim /var/lib/mysql/auto.cnf</code>  </p>
</li>
<li><p>重启MySQL <code>service mysql restart</code> </p>
</li>
<li><p>退出容器 <code>ctrl + p &amp;&amp; ctrl + q</code>  </p>
</li>
</ol>
<h2 id="创建从服务器登陆主服务器账号并授权"><a href="#创建从服务器登陆主服务器账号并授权" class="headerlink" title="创建从服务器登陆主服务器账号并授权"></a>创建从服务器登陆主服务器账号并授权</h2><ol>
<li><p>进入主服务器 <code>docker exec -it master bash</code>  </p>
</li>
<li><p>登陆mysql：<code>mysql -uroot -p123456</code>  </p>
</li>
<li><p>创建账号并授权<br> <code>create user root@&#39;slave.nw-ms&#39; identified by &#39;123456&#39;;</code>  登陆用户ip限制根据需要随意放宽<br> <code>grant replication slave on *.* to &#39;root&#39;@&#39;slave.nw-ms&#39; identified by ‘123456’;</code><br> <code>flush privileges;</code></p>
</li>
<li><p>查看当前log文件名及位置作为同步起始点（保证主库停止更新的情况下，如果还有更新任务，应暂时锁表禁止更新<code>FLUSH TABLES WITH READ LOCK</code>，待主从库数据相同，并且记录下主库file和position之后再解除<code>UNLOCK TABLES;</code>）<br> <code>show master status;</code> 如下所示，记录下File和Position</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">| mysql-bin.000001 |      752 |              |                  |                   |</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br></pre></td></tr></table></figure>
</li>
<li><p>退出主服务器<code>ctrl + p &amp;&amp; ctrl + q</code>  </p>
</li>
</ol>
<h2 id="从服务器配置"><a href="#从服务器配置" class="headerlink" title="从服务器配置"></a>从服务器配置</h2><p>确保从服务器数据与主服务器相同</p>
<ol>
<li><p>进入从服务器 <code>docker exec -it slave bash</code>  </p>
</li>
<li><p>登陆mysql：<code>mysql -uroot -p123456</code>  </p>
</li>
<li><p>设置同步参数 <code>change master to master_host=&#39;master&#39;, master_user=&#39;root&#39;, master_password=&#39;123456&#39;, master_log_file=&#39;mysql-bin.000001&#39;, master_log_pos=752;</code>   注：此处<code>master_host</code>对应docker容器运行时的<code>--network-alias</code>，也可直接使用ip地址，<code>master_log_file</code>和<code>master_log_pos</code>即对应前面<code>show master status;</code>所显示的数据  </p>
</li>
<li><p>开始同步 <code>start slave;</code>  </p>
</li>
<li><p>验证是否成功 <code>show slave status\G</code>，查看列出的信息内的以下两个参数值是否不为NO，否则同步失败，若同步失败可关注<code>Last_IO_Error</code>参数找出同步失败原因</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Slave_IO_Running: Yes  </span><br><span class="line">Slave_SQL_Running: Yes</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后就可以在主库中写一些数据试试看了</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://www.uetty.com/2018/12/30/mysql-slave/" data-id="ck0v87sn40010lwukmxd16mzs" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/">mysql</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-dubbo-retry-policy" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/15/dubbo-retry-policy/" class="article-date">
  <time datetime="2018-11-15T14:40:56.000Z" itemprop="datePublished">2018-11-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/15/dubbo-retry-policy/">dubbo启动时class not found org/apache/curator/RetryPolicy</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.NoClassDefFoundError: org/apache/curator/RetryPolicy</span><br><span class="line">	at com.alibaba.dubbo.remoting.zookeeper.curator.CuratorZookeeperTransporter.connect(CuratorZookeeperTransporter.java:27)</span><br><span class="line">	at com.alibaba.dubbo.remoting.zookeeper.ZookeeperTransporter$Adaptive.connect(ZookeeperTransporter$Adaptive.java)</span><br><span class="line">	at com.alibaba.dubbo.registry.zookeeper.ZookeeperRegistry.&lt;init&gt;(ZookeeperRegistry.java:69)</span><br><span class="line">	at com.alibaba.dubbo.registry.zookeeper.ZookeeperRegistryFactory.createRegistry(ZookeeperRegistryFactory.java:38)</span><br><span class="line">	at com.alibaba.dubbo.registry.support.AbstractRegistryFactory.getRegistry(AbstractRegistryFactory.java:96)</span><br><span class="line">	at com.alibaba.dubbo.registry.RegistryFactory$Adaptive.getRegistry(RegistryFactory$Adaptive.java)</span><br><span class="line">	at com.alibaba.dubbo.registry.integration.RegistryProtocol.getRegistry(RegistryProtocol.java:203)</span><br><span class="line">	at com.alibaba.dubbo.registry.integration.RegistryProtocol.export(RegistryProtocol.java:137)</span><br><span class="line">	at com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper.export(ProtocolFilterWrapper.java:98)</span><br><span class="line">	at com.alibaba.dubbo.rpc.protocol.ProtocolListenerWrapper.export(ProtocolListenerWrapper.java:55)</span><br><span class="line">	at com.alibaba.dubbo.qos.protocol.QosProtocolWrapper.export(QosProtocolWrapper.java:60)</span><br><span class="line">	at com.alibaba.dubbo.rpc.Protocol$Adaptive.export(Protocol$Adaptive.java)</span><br><span class="line">	at com.alibaba.dubbo.config.ServiceConfig.doExportUrlsFor1Protocol(ServiceConfig.java:513)</span><br><span class="line">	at com.alibaba.dubbo.config.ServiceConfig.doExportUrls(ServiceConfig.java:358)</span><br><span class="line">	at com.alibaba.dubbo.config.ServiceConfig.doExport(ServiceConfig.java:317)</span><br><span class="line">	at com.alibaba.dubbo.config.ServiceConfig.export(ServiceConfig.java:216)</span><br><span class="line">	at com.alibaba.dubbo.config.spring.ServiceBean.export(ServiceBean.java:291)</span><br><span class="line">	at com.alibaba.dubbo.config.spring.ServiceBean.onApplicationEvent(ServiceBean.java:131)</span><br><span class="line">	at com.alibaba.dubbo.config.spring.ServiceBean.onApplicationEvent(ServiceBean.java:53)</span><br><span class="line">	at org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:172)</span><br><span class="line">	at org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:165)</span><br><span class="line">	at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:139)</span><br><span class="line">	at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:398)</span><br><span class="line">	at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:355)</span><br><span class="line">	at org.springframework.context.support.AbstractApplicationContext.finishRefresh(AbstractApplicationContext.java:882)</span><br><span class="line">	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:549)</span><br><span class="line">	at org.springframework.context.support.ClassPathXmlApplicationContext.&lt;init&gt;(ClassPathXmlApplicationContext.java:144)</span><br><span class="line">	at org.springframework.context.support.ClassPathXmlApplicationContext.&lt;init&gt;(ClassPathXmlApplicationContext.java:95)</span><br><span class="line">	at com.uetty.dbo.service.App.main(App.java:18)</span><br><span class="line">Caused by: java.lang.ClassNotFoundException: org.apache.curator.RetryPolicy</span><br><span class="line">	at java.net.URLClassLoader.findClass(URLClassLoader.java:381)</span><br><span class="line">	at java.lang.ClassLoader.loadClass(ClassLoader.java:424)</span><br><span class="line">	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:338)</span><br><span class="line">	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)</span><br><span class="line">	... 29 more</span><br></pre></td></tr></table></figure>

<p>确保包含如下依赖，注意该依赖所依赖的的zookeeper的jar版本需与zookeeper服务器版本匹配，具体版本对应见zookeeper文档或者一个个版本调试一下试试（如果与zookeeper版本匹配问题会报KeeperErrorCode = Unimplemented错误）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;curator-framework&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://www.uetty.com/2018/11/15/dubbo-retry-policy/" data-id="ck0v87sn1000wlwukin9mfheb" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/dubbo/">dubbo</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-shadowsocks-server" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/01/shadowsocks-server/" class="article-date">
  <time datetime="2018-10-01T06:12:30.000Z" itemprop="datePublished">2018-10-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/01/shadowsocks-server/">shadowsocks docker 镜像实现代理 - 服务端（搭建代理服务器）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>基于Ubuntu 18.04 / Ubuntu 16.04测试，这里记录的是代理服务器的搭建，需要有一台境外的linux(各种发行版本的都行，只要能安装docker)服务器<br>docker 安装见 <a href="https://blog.csdn.net/Vincent_Field/article/details/82086197" target="_blank" rel="noopener">https://blog.csdn.net/Vincent_Field/article/details/82086197</a></p>
<h2 id="镜像获取"><a href="#镜像获取" class="headerlink" title="镜像获取"></a>镜像获取</h2><hr>
<p>docker pull uetty/shadowsocks:server</p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><hr>
<h3 id="初次启动"><a href="#初次启动" class="headerlink" title="初次启动"></a>初次启动</h3><blockquote>
<ol>
<li>宿主机上运行启动容器命令：<br>docker run –net=host –name=socks -t uetty/shadowsocks:server<br>ctrl + c 退出</li>
<li>进入容器内部：<br>docker exec -it socks bash<br>修改 /etc/shadowsocks.json 文件(vim /etc/shadowsocks.json)：<br>按i键编辑文件<br>设置端口、密码（可设置多对）、以及加密方式(method)<br>保存(依次：ctrl + c  -&gt;  输入:wq  -&gt;  回车)</li>
<li>在容器内部运行命令：<br>ssserver -c /etc/shadowsocks.json -d start<br>退出容器，先后按下：<br>ctrl + p     ctrl + q<br>在本地电脑使用客户端连接该服务器尝试是否代理成功</li>
</ol>
</blockquote>
<h3 id="关闭代理方式（第二步根据需要选择）"><a href="#关闭代理方式（第二步根据需要选择）" class="headerlink" title="关闭代理方式（第二步根据需要选择）"></a>关闭代理方式（第二步根据需要选择）</h3><blockquote>
<ol>
<li>进入容器：<br>docker exec -it socks bash<br>执行停止命令：<br>ssserver -c /etc/shadowsocks.json -d stop</li>
</ol>
</blockquote>
<h3 id="重启服务器后重新启动代理（服务器较少需要重启的情况）"><a href="#重启服务器后重新启动代理（服务器较少需要重启的情况）" class="headerlink" title="重启服务器后重新启动代理（服务器较少需要重启的情况）"></a>重启服务器后重新启动代理（服务器较少需要重启的情况）</h3><blockquote>
<ol>
<li>docker start socks</li>
<li>docker exec -it socks bash</li>
<li>此时已进入容器中，执行：<br>ssserver -c /etc/shadowsocks.json -d start</li>
</ol>
</blockquote>
<h3 id="尝试使用客户端连接服务器端代理"><a href="#尝试使用客户端连接服务器端代理" class="headerlink" title="尝试使用客户端连接服务器端代理"></a>尝试使用客户端连接服务器端代理</h3><blockquote>
<p><a href="https://raw.githubusercontent.com/Uetty/uetty.github.io/master/blog/影梭Win.zip" target="_blank" rel="noopener">Windows系统客户端</a></p>
<p><a href="./2018-09-21_shadowsocks.md">Ubuntu系统客户端教程</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://www.uetty.com/2018/10/01/shadowsocks-server/" data-id="ck0v87smz000ulwuk1j91o6rv" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-shadowsocks-client" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/21/shadowsocks-client/" class="article-date">
  <time datetime="2018-09-21T15:39:07.000Z" itemprop="datePublished">2018-09-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/21/shadowsocks-client/">shadowsocks docker 镜像实现代理 - 客户端（Ubuntu电脑访问服务器使用代理）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>基于Ubuntu 18.04测试，这里记录的是Ubuntu客户端使用代理的方式，服务端搭建代理服务器的移步<br>docker 安装见 <a href="https://blog.csdn.net/Vincent_Field/article/details/82086197" target="_blank" rel="noopener">https://blog.csdn.net/Vincent_Field/article/details/82086197</a><br>Windows系统的话，已经有现成的软件（<a href="../static/MB18092101-1.zip">影梭Win.zip</a>），该教程也就没有意义了  </p>
<h2 id="镜像获取"><a href="#镜像获取" class="headerlink" title="镜像获取"></a>镜像获取</h2><hr>
<p>docker pull uetty/shadowsocks:client</p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><hr>
<h3 id="初次启动"><a href="#初次启动" class="headerlink" title="初次启动"></a>初次启动</h3><blockquote>
<ol>
<li>宿主机上运行启动容器命令：<br>docker run –net=host –name=socks -t uetty/shadowsocks:client<br>ctrl + c 退出</li>
<li>进入容器内部：<br>docker exec -it socks bash<br>修改 /etc/shadowsocks.json 文件(vim /etc/shadowsocks.json)：<br>按i键编辑文件<br>修改服务器地址、端口、密码、以及加密方式(method)<br>保存(依次：ctrl + c  -&gt;  输入:wq  -&gt;  回车)</li>
<li>在容器内部运行命令：<br>sslocal -c /etc/shadowsocks.json -d start<br>退出容器，先后按下：<br>ctrl + p     ctrl + q</li>
<li>在宿主机上操作：<br>依次进入：设置 -&gt; 网络 -&gt; 网络代理 -&gt; 手动 -&gt; socks主机那行：<br>主机地址填写： 127.0.0.1 端口填写： 1080 忽略主机行填写（默认值）： localhost, 127.0.0.0/8, ::1<br>关闭设置<br>在浏览器上尝试是否代理成功</li>
</ol>
</blockquote>
<h3 id="关闭代理方式（第二步根据需要选择）"><a href="#关闭代理方式（第二步根据需要选择）" class="headerlink" title="关闭代理方式（第二步根据需要选择）"></a>关闭代理方式（第二步根据需要选择）</h3><blockquote>
<ol>
<li><p>将网络代理手动重新改为禁用</p>
</li>
<li><p>进入容器：<br>docker exec -it socks bash<br>执行停止命令：<br>sslocal -c /etc/shadowsocks.json -d stop</p>
</li>
</ol>
</blockquote>
<h3 id="重启电脑后重新启动代理"><a href="#重启电脑后重新启动代理" class="headerlink" title="重启电脑后重新启动代理"></a>重启电脑后重新启动代理</h3><blockquote>
<ol>
<li><p>docker start socks</p>
</li>
<li><p>docker exec -it socks bash</p>
</li>
<li><p>此时已进入容器中，执行：<br>sslocal -c /etc/shadowsocks.json -d start</p>
</li>
<li><p>退出容器，设置中设置手动代理</p>
</li>
</ol>
</blockquote>
<h3 id="命令行下使用代理"><a href="#命令行下使用代理" class="headerlink" title="命令行下使用代理"></a>命令行下使用代理</h3><blockquote>
<ol>
<li><p>在宿主机上执行（从container中将已准备好的工具拷贝出来）：<br>docker cp socks:/data/proxychains-ng.tar ~/data/proxychains-ng.tar<br>拷贝出来的位置随意自己决定</p>
</li>
<li><p>解压<br>cd ~/data<br>tar xf proxychains-ng.tar</p>
</li>
<li><p>安装<br>./configure<br>make<br>sudo make install<br>sudo cp ./src/proxychains.conf /etc/proxychains.conf<br>cd .. &amp;&amp; rm -rf proxychains-ng</p>
</li>
<li><p>修改配置<br>sudo vim /etc/proxychains.conf<br>修改最后一行为：<br>socks5 127.0.0.1 1080</p>
</li>
<li><p>使用<br>在需要代理的命令前增加：sudo proxychains4<br>如：<br>sudo proxychains4 ping <a href="http://www.docker.com" target="_blank" rel="noopener">www.docker.com</a><br>或<br>sudo proxychains4 -q ping <a href="http://www.docker.com" target="_blank" rel="noopener">www.docker.com</a></p>
</li>
</ol>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://www.uetty.com/2018/09/21/shadowsocks-client/" data-id="ck0v87sn50012lwukzrlf8gc4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-shadowsocks" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/07/shadowsocks/" class="article-date">
  <time datetime="2018-09-07T15:44:29.000Z" itemprop="datePublished">2018-09-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/07/shadowsocks/">Ubuntu shadowsocks 客户端代理记录（本地端用ubuntu setting替代chrome浏览器插件）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>基于Ubuntu 18.04测试，这里记录的是Ubuntu客户端使用代理的方式，服务端搭建代理服务器的移步<br>Windows系统的话，已经有现成的软件（<a href="https://raw.githubusercontent.com/Uetty/uetty.github.io/master/blog/影梭Win.zip" target="_blank" rel="noopener">Windows系统客户端</a>），该教程也就没有意义了  </p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><hr>
<ul>
<li>sudo apt-get update</li>
<li>sudo apt-get install python-pip</li>
<li>sudo apt-get install shadowsocks</li>
<li>sudo vim /etc/shadowsocks.json</li>
</ul>
<p>输入以下内容后保存</p>
<blockquote>
<p>{<br>    “server”:”xx.xx.xx.xx”, // 远程服务器地址<br>    “server_port”:xxxx, // 远程服务器端口<br>    “local_address”: “127.0.0.1”, // 本机地址<br>    “local_port”:1080, // 本机用于代理的端口<br>    “password”:”xxxxx”, // 密码<br>    “timeout”:300, // 超时<br>    “method”:”aes-256-cfb”, // 加密方式<br>    “fast_open”: true,<br>    “workers”: 1<br>}</p>
</blockquote>
<p>sudo sslocal -c /etc/shadowsocks.json -d start      启动服务（以后可以通过这个命令启动socks服务）</p>
<h2 id="chrome浏览器代理"><a href="#chrome浏览器代理" class="headerlink" title="chrome浏览器代理"></a>chrome浏览器代理</h2><hr>
<p>打开操作系统的设置 -&gt; 网络 -&gt; 网络代理，选择手动代理，只需填两行，Socks主机：127.0.0.1  1080，忽略主机：localhost, 127.0.0.0/8, ::1，忽略主机项表示不经过代理的网站，还可以逗号补上不想被代理的地址，如：<a href="http://www.baidu.com等。这时浏览器就能通过代理加速访问需要访问的网站。" target="_blank" rel="noopener">www.baidu.com等。这时浏览器就能通过代理加速访问需要访问的网站。</a></p>
<h2 id="命令行终端代理"><a href="#命令行终端代理" class="headerlink" title="命令行终端代理"></a>命令行终端代理</h2><hr>
<p>前面的设置下，命令行终端并没有经过代理。需要经过以下步骤进行：</p>
<ul>
<li>git clone <a href="https://github.com/rofl0r/proxychains-ng.git" target="_blank" rel="noopener">https://github.com/rofl0r/proxychains-ng.git</a></li>
<li>cd proxychains-ng</li>
<li>./configure</li>
<li>make</li>
<li>sudo make install</li>
<li>sudo cp ./src/proxychains.conf /etc/proxychains.conf</li>
<li>cd .. &amp;&amp; rm -rf proxychains-ng       (根据需要选择删除原来的安装源码)</li>
<li>sudo vim /etc/proxychains.conf       修改最后一行为：socks5  127.0.0.1 1080</li>
</ul>
<p>这时候，命令行终端如果需要经过代理，可以在命令前面添加：sudo proxychains4 指令，如果不想输出proxychains的日志信息可以使用：sudo proxychains4 -q，如：</p>
<blockquote>
<p>添加docker ppa时，由于网络问题，原来的命令<br>sudo add-apt-repository “deb [arch=amd64] <a href="https://download.docker.com/linux/ubuntu" target="_blank" rel="noopener">https://download.docker.com/linux/ubuntu</a> $(lsb_release -cs) stable”<br>不能成功执行，这时命令修改成：<br>sudo proxychains4 add-apt-repository “deb [arch=amd64] <a href="https://download.docker.com/linux/ubuntu" target="_blank" rel="noopener">https://download.docker.com/linux/ubuntu</a> $(lsb_release -cs) stable”<br>使得该命令的网络经过代理，可以成功完成</p>
<p>还可以：<br>sudo proxychains4 ping <a href="http://www.docker.com" target="_blank" rel="noopener">www.docker.com</a><br>sudo proxychains4 apt-get update<br>sudo proxychains4 -q apt-cache madison mysql-server       (-q 安静模式，不输出proxychains4的日志)<br>sudo proxychains4 apt-get install mysql-server</p>
</blockquote>
<p>参考自：<a href="https://blog.csdn.net/lee_j_r/article/details/54019691" target="_blank" rel="noopener">https://blog.csdn.net/lee_j_r/article/details/54019691</a><br>主要不同点： chrome浏览器代理（修改理由：在没有代理之前，不能打开插件市场安装管理插件，因此修改了代理方式）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://www.uetty.com/2018/09/07/shadowsocks/" data-id="ck0v87smx000slwukeu0t6xm5" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/IDE/">IDE</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MyBatis/">MyBatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RabbitMQ/">RabbitMQ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/api/">api</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/">css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dubbo/">dubbo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/log4j/">log4j</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/maven/">maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/open-source/">open source</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/">spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vulnerability/">vulnerability</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/IDE/" style="font-size: 10px;">IDE</a> <a href="/tags/MyBatis/" style="font-size: 10px;">MyBatis</a> <a href="/tags/RabbitMQ/" style="font-size: 10px;">RabbitMQ</a> <a href="/tags/api/" style="font-size: 10px;">api</a> <a href="/tags/css/" style="font-size: 10px;">css</a> <a href="/tags/docker/" style="font-size: 10px;">docker</a> <a href="/tags/dubbo/" style="font-size: 10px;">dubbo</a> <a href="/tags/java/" style="font-size: 20px;">java</a> <a href="/tags/linux/" style="font-size: 17.5px;">linux</a> <a href="/tags/log4j/" style="font-size: 10px;">log4j</a> <a href="/tags/maven/" style="font-size: 10px;">maven</a> <a href="/tags/mysql/" style="font-size: 12.5px;">mysql</a> <a href="/tags/open-source/" style="font-size: 10px;">open source</a> <a href="/tags/redis/" style="font-size: 10px;">redis</a> <a href="/tags/spring/" style="font-size: 15px;">spring</a> <a href="/tags/vulnerability/" style="font-size: 10px;">vulnerability</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">2019-08</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">2019-07</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">2019-06</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">2019-05</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">2019-04</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">2019-03</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">2019-02</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">2018-12</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">2018-11</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">2018-10</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">2018-09</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">2018-08</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">2018-06</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">2018-03</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">2018-02</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">2017-12</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">2017-09</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">2017-08</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">2017-07</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">2017-05</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">2017-03</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/08/15/log4j/">log4j xml配置文件个人配置如何不污染GIT远程仓库</a>
          </li>
        
          <li>
            <a href="/2019/07/31/common-excel/">阿里Easy Excel自定义样式注解</a>
          </li>
        
          <li>
            <a href="/2019/07/29/compare-list-vertor-cowlist/">ArrayList、Vector、CopyOnWriteArrayList对比</a>
          </li>
        
          <li>
            <a href="/2019/07/17/java-garbage-collector/">JAVA垃圾收集器科普</a>
          </li>
        
          <li>
            <a href="/2019/07/10/java-linux-timezone/">Java及Ubuntu操作系统时区错误</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Vince<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>